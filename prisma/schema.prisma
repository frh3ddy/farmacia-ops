generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model Location {
  id       String  @id @default(uuid())
  squareId String? @unique
  name     String
  address  String?
  isActive Boolean @default(true)

  inventories     Inventory[]
  expenses        Expense[]
  sales           Sale[]
  racks           Rack[]
  catalogMappings CatalogMapping[]
  cutoverLocks    CutoverLock[]

  createdAt DateTime @default(now())
}

model User {
  id   String   @id @default(uuid())
  role UserRole @default(OWNER)

  createdAt DateTime @default(now())
}

enum UserRole {
  OWNER
}

enum MigrationStatus {
  PENDING
  APPROVED
  SKIPPED
}

model Product {
  id         String  @id @default(uuid())
  name       String
  sku        String? @unique
  categoryId String?

  // Square catalog data (cached to avoid API calls during extraction)
  squareProductName   String? // Product name from Square ITEM
  squareDescription   String? // Product description from Square ITEM
  squareImageUrl      String? // Product image URL from Square
  squareVariationName String? // Variation name from Square
  squareDataSyncedAt  DateTime? // When Square data was last synced

  category            Category?             @relation(fields: [categoryId], references: [id])
  suppliers           SupplierProduct[]
  supplierCostHistory SupplierCostHistory[]
  inventories         Inventory[]
  placements          Placement[]
  saleItems           SaleItem[]
  catalogMappings     CatalogMapping[]
  costApprovals       CostApproval[]

  createdAt DateTime @default(now())
}

model Category {
  id   String @id @default(uuid())
  name String

  products Product[]
}

model Supplier {
  id             String   @id @default(uuid())
  name           String
  normalizedName String   @unique // Normalized name for race-free matching
  initials       String[] @default([]) // Array of initials for cost extraction (e.g., ["L", "Lev", "Levi"])
  contactInfo    String?
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  products    SupplierProduct[]
  costHistory SupplierCostHistory[]
}

model SupplierProduct {
  id         String @id @default(uuid())
  supplierId String
  productId  String

  cost        Decimal
  isPreferred Boolean @default(false)
  notes       String?

  supplier Supplier @relation(fields: [supplierId], references: [id])
  product  Product  @relation(fields: [productId], references: [id])

  @@unique([supplierId, productId])
}

model Inventory {
  id         String @id @default(uuid())
  locationId String
  productId  String

  quantity    Int
  receivedAt  DateTime
  unitCost    Decimal
  source      String? // "OPENING_BALANCE", "PURCHASE", "ADJUSTMENT"
  costSource  String? // "SQUARE_COST", "DESCRIPTION", "MANUAL_INPUT", "AVERAGE_COST"
  migrationId String? // Reference to cutover

  location Location @relation(fields: [locationId], references: [id])
  product  Product  @relation(fields: [productId], references: [id])

  createdAt DateTime @default(now())


  @@index([productId])
  @@index([locationId])
  @@index([source])
  @@unique([productId, locationId, source])
}

model Sale {
  id         String @id @default(uuid())
  squareId   String @unique
  locationId String

  totalRevenue Decimal
  totalCost    Decimal
  grossProfit  Decimal

  createdAt DateTime

  items SaleItem[]

  location Location @relation(fields: [locationId], references: [id])
}

model SaleItem {
  id        String @id @default(uuid())
  saleId    String
  productId String

  quantity Int
  price    Decimal
  cost     Decimal

  sale    Sale    @relation(fields: [saleId], references: [id])
  product Product @relation(fields: [productId], references: [id])
}

model Expense {
  id         String @id @default(uuid())
  locationId String

  type   ExpenseType
  amount Decimal
  date   DateTime

  location Location @relation(fields: [locationId], references: [id])
}

enum ExpenseType {
  RENT
  UTILITIES
  PAYROLL
  OTHER
}

model Rack {
  id         String @id @default(uuid())
  locationId String
  name       String

  sections RackSection[]

  location Location @relation(fields: [locationId], references: [id])
}

model RackSection {
  id     String @id @default(uuid())
  rackId String
  label  String
  size   String

  placements Placement[]

  rack Rack @relation(fields: [rackId], references: [id])
}

model Placement {
  id            String @id @default(uuid())
  productId     String
  rackSectionId String

  product Product     @relation(fields: [productId], references: [id])
  section RackSection @relation(fields: [rackSectionId], references: [id])
}

model DemandSignal {
  id         String @id @default(uuid())
  query      String
  locationId String

  count Int @default(1)

  createdAt DateTime @default(now())
}

model CatalogMapping {
  id                String   @id @default(uuid())
  squareVariationId String   // ITEM_VARIATION.id from Square
  productId         String
  locationId        String?  // Optional, null = global mapping

  // Cached selling price from Square
  priceCents    Decimal? // Selling price in cents (from price_money.amount)
  currency      String?  // Currency code (e.g., "USD")
  priceSyncedAt DateTime? // When price was last synced from Square

  product  Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
  location Location? @relation(fields: [locationId], references: [id], onDelete: Cascade)

  syncedAt  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([squareVariationId, locationId]) // Unique per variation+location combination
  @@index([productId])
  @@index([locationId])
  @@index([squareVariationId])
}

model CostApproval {
  id             String          @id @default(uuid())
  cutoverId      String
  batchId        String?         // Reference to ExtractionBatch
  productId      String
  approvedCost   Decimal
  source         String          // "EXTRACTED_LAST", "EXTRACTED_SELECTED", "MANUAL_OVERRIDE", "BATCH_APPROVED"
  notes          String?
  approvedAt     DateTime        @default(now())
  approvedBy     String?         // User ID
  migrationStatus MigrationStatus @default(PENDING)

  product Product        @relation(fields: [productId], references: [id])
  batch   ExtractionBatch? @relation(fields: [batchId], references: [id])

  @@unique([cutoverId, productId])
  @@index([cutoverId])
  @@index([batchId])
  @@index([migrationStatus])
}

model Cutover {
  id              String    @id @default(uuid())
  cutoverDate     DateTime
  costBasis       String
  ownerApproved   Boolean
  ownerApprovedAt DateTime?
  ownerApprovedBy String?
  completedAt     DateTime?
  status          String // "PENDING", "COMPLETED", "FAILED", "IN_PROGRESS"
  result          Json? // Store MigrationResult
  batchSize       Int? // Number of items per batch
  currentBatch    Int? // Current batch being processed
  totalBatches    Int? // Total number of batches
  processedItems  Int? // Number of items processed so far
  totalItems      Int? // Total items to process
  batchState      Json? // Store state for resuming batches (processed product IDs, etc.)
  createdAt       DateTime  @default(now())
}

model CutoverLock {
  id          String   @id @default(uuid())
  locationId  String?
  cutoverDate DateTime
  isLocked    Boolean  @default(true)
  lockedAt    DateTime @default(now())
  lockedBy    String?

  location Location? @relation(fields: [locationId], references: [id])


  @@index([locationId])
  @@index([cutoverDate])
  @@unique([locationId, cutoverDate])
}

model SupplierCostHistory {
  id          String   @id @default(uuid())
  productId   String
  supplierId  String
  unitCost    Decimal
  effectiveAt DateTime
  source      String // "MIGRATION" | "INVENTORY_UPDATE" | "MANUAL"
  isCurrent   Boolean  @default(true)
  createdAt   DateTime @default(now())

  product  Product  @relation(fields: [productId], references: [id])
  supplier Supplier @relation(fields: [supplierId], references: [id])

  @@index([productId, supplierId])
  @@index([isCurrent])
}

model ExtractionSession {
  id                    String   @id @default(uuid())
  cutoverId             String?  // Optional link to cutover
  locationIds           String[] // Array of location IDs

  // Session state
  currentBatch          Int      @default(1)
  totalBatches          Int?
  totalItems            Int
  processedItems        Int      @default(0)
  batchSize             Int

  // Last approved tracking
  lastApprovedBatchId   String?  // Last batch that was fully approved
  lastApprovedProductId String?  // Last product ID that was approved across all batches

  // Supplier initials learned from user corrections
  learnedSupplierInitials Json?  // Map of supplier names to their initials arrays
  // Format: { "Levic": ["L", "Lev", "Levi"], "Center": ["C", "Cent"] }

  status                String   @default("IN_PROGRESS") // "IN_PROGRESS", "COMPLETED", "CANCELLED"

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  batches               ExtractionBatch[]

  @@index([cutoverId])
  @@index([status])
}

model ExtractionBatch {
  id                    String   @id @default(uuid())
  extractionSessionId   String   // Links to extraction session
  batchNumber           Int      // Sequential batch number (1, 2, 3, ...)
  cutoverId             String?  // Optional link to cutover
  locationIds           String[] // Array of location IDs

  // Batch status
  status                String   @default("EXTRACTED") // "EXTRACTED", "APPROVED", "REJECTED"
  extractedAt           DateTime @default(now())
  approvedAt            DateTime?
  approvedBy            String?  // User ID

  // Product tracking
  productIds            String[] // Array of product IDs in this batch
  totalProducts         Int
  productsWithExtraction Int
  productsRequiringManualInput Int

  // Approval tracking
  extractionApproved    Boolean  @default(false) // Checkbox for extraction approval
  manualInputApproved   Boolean  @default(false) // Checkbox for manual input approval
  isFullyApproved       Boolean  @default(false) // Both checkboxes must be true

  // Last approved item tracking
  lastApprovedProductId String?  // Last product ID that was approved in this batch

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  session               ExtractionSession @relation(fields: [extractionSessionId], references: [id])
  approvals             CostApproval[]

  @@index([extractionSessionId])
  @@index([cutoverId])
  @@index([status])
}
