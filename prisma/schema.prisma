generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model Location {
  id       String  @id @default(uuid())
  squareId String? @unique
  name     String
  address  String?
  isActive Boolean @default(true)

  inventories     Inventory[]
  expenses        Expense[]
  sales           Sale[]
  racks           Rack[]
  catalogMappings CatalogMapping[]
  cutoverLocks    CutoverLock[]
  adjustments     InventoryAdjustment[]
  receivings      InventoryReceiving[]

  // Authentication relations
  devices     Device[]
  employeeAssignments EmployeeLocationAssignment[]

  createdAt DateTime @default(now())
}

// ============================================================================
// Authentication & Authorization Models (Phase F)
// Multi-user PIN access for retail POS with role-based permissions
// ============================================================================

// Device - represents an activated iPad/tablet at a location
model Device {
  id            String    @id @default(uuid())
  locationId    String
  name          String    // "iPad Pro - Front Counter"
  deviceToken   String    @unique // dt_<uuid> format
  type          DeviceType @default(FIXED)
  isActive      Boolean   @default(true)
  lastActiveAt  DateTime?
  activatedAt   DateTime  @default(now())
  activatedBy   String    // Employee ID who activated

  location Location @relation(fields: [locationId], references: [id])

  @@index([deviceToken])
  @@index([locationId])
}

enum DeviceType {
  FIXED   // iPad at counter, locked to one location
  MOBILE  // Mobile device, can switch locations
  WEB     // Web browser session
}

// Employee - a person who can log in with PIN
model Employee {
  id           String    @id @default(uuid())
  name         String
  email        String?   @unique
  passwordHash String?   // Only for owner/manager device activation
  pin          String?   // Hashed 4-6 digit PIN
  pinSalt      String?   // Salt for PIN hashing
  pinFailedAttempts Int  @default(0)
  pinLockedUntil DateTime?
  isActive     Boolean   @default(true)
  lastLoginAt  DateTime?
  createdAt    DateTime  @default(now())
  createdBy    String?   // Employee ID who created this employee

  // Relations
  assignments  EmployeeLocationAssignment[]
  auditLogs    AuditLog[]
  sessions     EmployeeSession[]

  @@index([email])
  @@index([isActive])
}

// Role assignment per location - allows different roles at different stores
model EmployeeLocationAssignment {
  id         String       @id @default(uuid())
  employeeId String
  locationId String
  role       EmployeeRole
  isActive   Boolean      @default(true)
  assignedAt DateTime     @default(now())
  assignedBy String?      // Employee ID who made this assignment

  employee Employee @relation(fields: [employeeId], references: [id])
  location Location @relation(fields: [locationId], references: [id])

  @@unique([employeeId, locationId])
  @@index([employeeId])
  @@index([locationId])
  @@index([role])
}

enum EmployeeRole {
  OWNER      // Full access to everything
  MANAGER    // Inventory operations, reports, limited employee management
  CASHIER    // Read-only inventory access
  ACCOUNTANT // Expenses, reports, read-only inventory
}

// Session - tracks active employee sessions
model EmployeeSession {
  id           String   @id @default(uuid())
  employeeId   String
  deviceToken  String   // Links to device
  sessionToken String   @unique // st_<uuid> format
  locationId   String   // Current location context
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  lastActivityAt DateTime @default(now())

  employee Employee @relation(fields: [employeeId], references: [id])

  @@index([sessionToken])
  @@index([employeeId])
  @@index([deviceToken])
  @@index([expiresAt])
}

// Audit log for all significant actions
model AuditLog {
  id         String   @id @default(uuid())
  employeeId String?
  deviceId   String?
  locationId String?
  action     String   // "LOGIN", "LOGOUT", "CREATE_EXPENSE", etc.
  entityType String?  // "Expense", "InventoryAdjustment", etc.
  entityId   String?
  details    Json?    // Additional context
  ipAddress  String?
  userAgent  String?
  timestamp  DateTime @default(now())

  employee Employee? @relation(fields: [employeeId], references: [id])

  @@index([employeeId])
  @@index([locationId])
  @@index([timestamp])
  @@index([action])
  @@index([entityType, entityId])
}

// Legacy User model (kept for backwards compatibility)
model User {
  id   String   @id @default(uuid())
  role UserRole @default(OWNER)

  createdAt DateTime @default(now())
}

enum UserRole {
  OWNER
}

enum MigrationStatus {
  PENDING
  APPROVED
  SKIPPED
}

model Product {
  id         String  @id @default(uuid())
  name       String
  sku        String? @unique
  categoryId String?

  // Square catalog data (cached to avoid API calls during extraction)
  squareProductName   String? // Product name from Square ITEM
  squareDescription   String? // Product description from Square ITEM
  squareImageUrl      String? // Product image URL from Square
  squareVariationName String? // Variation name from Square
  squareDataSyncedAt  DateTime? // When Square data was last synced

  category            Category?             @relation(fields: [categoryId], references: [id])
  suppliers           SupplierProduct[]
  supplierCostHistory SupplierCostHistory[]
  inventories         Inventory[]
  placements          Placement[]
  saleItems           SaleItem[]
  catalogMappings     CatalogMapping[]
  costApprovals       CostApproval[]
  adjustments         InventoryAdjustment[]
  receivings          InventoryReceiving[]

  createdAt DateTime @default(now())
}

model Category {
  id   String @id @default(uuid())
  name String

  products Product[]
}

model Supplier {
  id             String   @id @default(uuid())
  name           String
  normalizedName String   @unique // Normalized name for race-free matching
  initials       String[] @default([]) // Array of initials for cost extraction (e.g., ["L", "Lev", "Levi"])
  contactInfo    String?
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  products    SupplierProduct[]
  costHistory SupplierCostHistory[]
  receivings  InventoryReceiving[]
}

model SupplierProduct {
  id         String @id @default(uuid())
  supplierId String
  productId  String

  cost        Decimal
  isPreferred Boolean @default(false)
  notes       String?

  supplier Supplier @relation(fields: [supplierId], references: [id])
  product  Product  @relation(fields: [productId], references: [id])

  @@unique([supplierId, productId])
}

model Inventory {
  id         String @id @default(uuid())
  locationId String
  productId  String

  quantity    Int
  receivedAt  DateTime
  unitCost    Decimal
  source      String? // "OPENING_BALANCE", "PURCHASE", "ADJUSTMENT"
  costSource  String? // "SQUARE_COST", "DESCRIPTION", "MANUAL_INPUT", "AVERAGE_COST"
  migrationId String? // Reference to cutover

  location Location @relation(fields: [locationId], references: [id])
  product  Product  @relation(fields: [productId], references: [id])

  // Consumption records for FIFO audit trail
  consumptions InventoryConsumption[]

  // Created by positive adjustment
  createdByAdjustment InventoryAdjustment? @relation("AdjustmentCreatedBatch")

  // Created by receiving
  createdByReceiving InventoryReceiving? @relation("ReceivingCreatedBatch")

  createdAt DateTime @default(now())

  // Note: Removed unique constraint on (productId, locationId, source) to allow multiple FIFO batches
  // Each receiving/adjustment creates a new batch with the same product/location
  @@index([productId])
  @@index([locationId])
  @@index([source])
  @@index([receivedAt]) // Important for FIFO ordering
}

model Sale {
  id         String @id @default(uuid())
  squareId   String @unique
  locationId String

  totalRevenue Decimal
  totalCost    Decimal
  grossProfit  Decimal

  createdAt DateTime

  items SaleItem[]

  location Location @relation(fields: [locationId], references: [id])
}

model SaleItem {
  id        String @id @default(uuid())
  saleId    String
  productId String

  quantity Int
  price    Decimal
  cost     Decimal

  sale    Sale    @relation(fields: [saleId], references: [id])
  product Product @relation(fields: [productId], references: [id])

  // Consumption records for FIFO audit trail
  consumptions InventoryConsumption[]
}

// ============================================================================
// FIFO Audit Trail - InventoryConsumption
// Records which inventory batches were consumed for each sale/adjustment
// This is APPEND-ONLY and IMMUTABLE for audit integrity
// ============================================================================
model InventoryConsumption {
  id String @id @default(uuid())

  // Source of consumption
  inventoryId  String // The inventory batch that was consumed
  saleItemId   String? // If consumed by a sale (nullable for adjustments)
  adjustmentId String? // If consumed by an adjustment (future use)

  // Consumption details
  quantity  Int // Quantity consumed from this batch
  unitCost  Decimal // Unit cost at time of consumption (snapshot)
  totalCost Decimal // quantity * unitCost (precomputed for reports)

  // Audit metadata
  consumedAt DateTime @default(now())

  // Relations
  inventory  Inventory            @relation(fields: [inventoryId], references: [id])
  saleItem   SaleItem?            @relation(fields: [saleItemId], references: [id])
  adjustment InventoryAdjustment? @relation(fields: [adjustmentId], references: [id])

  // Indexes for efficient queries
  @@index([inventoryId])
  @@index([saleItemId])
  @@index([adjustmentId])
  @@index([consumedAt])
}

// ============================================================================
// Inventory Adjustments
// Records inventory changes not from sales (damage, theft, expired, corrections)
// This is APPEND-ONLY and IMMUTABLE for audit integrity
// ============================================================================
model InventoryAdjustment {
  id         String @id @default(uuid())
  locationId String
  productId  String

  // Adjustment details
  type          AdjustmentType
  quantity      Int // Positive = add inventory, Negative = remove inventory
  reason        String? // Human-readable reason
  notes         String? // Additional notes

  // Cost tracking
  unitCost      Decimal // Cost per unit (for valuation)
  totalCost     Decimal // |quantity| * unitCost (always positive for reporting)

  // For positive adjustments: reference to created inventory batch
  createdBatchId String? @unique

  // Audit metadata
  adjustedAt    DateTime @default(now())
  adjustedBy    String? // User ID who made the adjustment

  // Cutover validation
  effectiveDate DateTime @default(now()) // Date the adjustment applies to

  // Relations
  location      Location @relation(fields: [locationId], references: [id])
  product       Product  @relation(fields: [productId], references: [id])
  createdBatch  Inventory? @relation("AdjustmentCreatedBatch", fields: [createdBatchId], references: [id])

  // Consumption records (for negative adjustments - FIFO trail)
  consumptions  InventoryConsumption[]

  @@index([locationId])
  @@index([productId])
  @@index([type])
  @@index([adjustedAt])
  @@index([effectiveDate])
}

enum AdjustmentType {
  DAMAGE          // Product damaged, unsellable
  THEFT           // Product stolen/missing
  EXPIRED         // Product past expiration
  COUNT_CORRECTION // Physical count doesn't match system
  FOUND           // Product found (positive adjustment)
  RETURN          // Customer return (positive adjustment)
  TRANSFER_OUT    // Transferred to another location (negative)
  TRANSFER_IN     // Received from another location (positive)
  WRITE_OFF       // General write-off
  OTHER           // Other reason (requires notes)
}

// ============================================================================
// Inventory Receiving
// Records inventory receipts from suppliers/purchases
// Links to Inventory batches for FIFO tracking
// ============================================================================
model InventoryReceiving {
  id         String @id @default(uuid())
  locationId String
  productId  String
  supplierId String?

  // Receiving details
  quantity      Int
  unitCost      Decimal
  totalCost     Decimal // quantity * unitCost

  // Reference numbers
  invoiceNumber   String?  // Supplier invoice number
  purchaseOrderId String?  // Internal PO reference
  batchNumber     String?  // Lot/batch number from supplier
  
  // Product tracking
  expiryDate      DateTime? // Product expiration date
  manufacturingDate DateTime? // Manufacturing date if known

  // Created inventory batch reference
  inventoryBatchId String @unique

  // Square sync tracking
  squareSynced    Boolean @default(false)
  squareSyncedAt  DateTime?
  squareSyncError String?

  // Audit metadata
  receivedAt   DateTime @default(now())
  receivedBy   String?  // User ID who received
  notes        String?

  // Relations
  location       Location   @relation(fields: [locationId], references: [id])
  product        Product    @relation(fields: [productId], references: [id])
  supplier       Supplier?  @relation(fields: [supplierId], references: [id])
  inventoryBatch Inventory  @relation("ReceivingCreatedBatch", fields: [inventoryBatchId], references: [id])

  @@index([locationId])
  @@index([productId])
  @@index([supplierId])
  @@index([receivedAt])
  @@index([invoiceNumber])
  @@index([batchNumber])
}

model Expense {
  id         String @id @default(uuid())
  locationId String

  type        ExpenseType
  amount      Decimal
  date        DateTime
  description String?      // Description of the expense
  vendor      String?      // Who was paid (landlord, utility company, etc.)
  reference   String?      // Invoice/receipt number
  isPaid      Boolean      @default(true)
  paidAt      DateTime?
  notes       String?
  createdBy   String?      // User who recorded it
  createdAt   DateTime     @default(now())

  location Location @relation(fields: [locationId], references: [id])

  @@index([locationId])
  @@index([type])
  @@index([date])
}

enum ExpenseType {
  RENT
  UTILITIES
  PAYROLL
  INSURANCE
  SUPPLIES      // Office/store supplies (not inventory)
  MARKETING
  MAINTENANCE
  TAXES
  BANK_FEES
  SOFTWARE      // POS software, subscriptions
  PROFESSIONAL  // Accountant, lawyer fees
  OTHER
}

model Rack {
  id         String @id @default(uuid())
  locationId String
  name       String

  sections RackSection[]

  location Location @relation(fields: [locationId], references: [id])
}

model RackSection {
  id     String @id @default(uuid())
  rackId String
  label  String
  size   String

  placements Placement[]

  rack Rack @relation(fields: [rackId], references: [id])
}

model Placement {
  id            String @id @default(uuid())
  productId     String
  rackSectionId String

  product Product     @relation(fields: [productId], references: [id])
  section RackSection @relation(fields: [rackSectionId], references: [id])
}

model DemandSignal {
  id         String @id @default(uuid())
  query      String
  locationId String

  count Int @default(1)

  createdAt DateTime @default(now())
}

model CatalogMapping {
  id                String  @id @default(uuid())
  squareVariationId String // ITEM_VARIATION.id from Square
  productId         String
  locationId        String? // Optional, null = global mapping

  // Cached selling price from Square
  priceCents    Decimal? // Selling price in cents (from price_money.amount)
  currency      String? // Currency code (e.g., "USD")
  priceSyncedAt DateTime? // When price was last synced from Square

  product  Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
  location Location? @relation(fields: [locationId], references: [id], onDelete: Cascade)

  syncedAt  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([squareVariationId, locationId]) // Unique per variation+location combination
  @@index([productId])
  @@index([locationId])
  @@index([squareVariationId])
}

model CostApproval {
  id              String          @id @default(uuid())
  cutoverId       String
  batchId         String? // Reference to ExtractionBatch
  productId       String
  approvedCost    Decimal
  source          String // "EXTRACTED_LAST", "EXTRACTED_SELECTED", "MANUAL_OVERRIDE", "BATCH_APPROVED"
  notes           String?
  approvedAt      DateTime        @default(now())
  approvedBy      String? // User ID
  migrationStatus MigrationStatus @default(PENDING)

  // Selling price data (stored for reconstruction)
  sellingPriceCents         Int? // Minimum selling price in cents
  sellingPriceCurrency      String? // Currency code (e.g., "USD")
  sellingPriceRangeMinCents Int? // Minimum price in range (if multiple variations)
  sellingPriceRangeMaxCents Int? // Maximum price in range (if multiple variations)

  product Product          @relation(fields: [productId], references: [id])
  batch   ExtractionBatch? @relation(fields: [batchId], references: [id])

  @@unique([cutoverId, productId])
  @@index([cutoverId])
  @@index([batchId])
  @@index([migrationStatus])
}

model Cutover {
  id              String    @id @default(uuid())
  cutoverDate     DateTime
  costBasis       String
  ownerApproved   Boolean
  ownerApprovedAt DateTime?
  ownerApprovedBy String?
  completedAt     DateTime?
  status          String // "PENDING", "COMPLETED", "FAILED", "IN_PROGRESS"
  result          Json? // Store MigrationResult
  batchSize       Int? // Number of items per batch
  currentBatch    Int? // Current batch being processed
  totalBatches    Int? // Total number of batches
  processedItems  Int? // Number of items processed so far
  totalItems      Int? // Total items to process
  batchState      Json? // Store state for resuming batches (processed product IDs, etc.)
  createdAt       DateTime  @default(now())
}

model CutoverLock {
  id          String   @id @default(uuid())
  locationId  String?
  cutoverDate DateTime
  isLocked    Boolean  @default(true)
  lockedAt    DateTime @default(now())
  lockedBy    String?

  location Location? @relation(fields: [locationId], references: [id])

  @@unique([locationId, cutoverDate])
  @@index([locationId])
  @@index([cutoverDate])
}

model SupplierCostHistory {
  id          String   @id @default(uuid())
  productId   String
  supplierId  String
  unitCost    Decimal
  effectiveAt DateTime
  source      String // "MIGRATION" | "INVENTORY_UPDATE" | "MANUAL"
  isCurrent   Boolean  @default(true)
  createdAt   DateTime @default(now())

  product  Product  @relation(fields: [productId], references: [id])
  supplier Supplier @relation(fields: [supplierId], references: [id])

  @@index([productId, supplierId])
  @@index([isCurrent])
}

model ExtractionSession {
  id          String   @id @default(uuid())
  cutoverId   String? // Optional link to cutover
  locationIds String[] // Array of location IDs

  // Session state
  currentBatch   Int  @default(1)
  totalBatches   Int?
  totalItems     Int
  processedItems Int  @default(0)
  batchSize      Int

  // Last approved tracking
  lastApprovedBatchId   String? // Last batch that was fully approved
  lastApprovedProductId String? // Last product ID that was approved across all batches

  // Supplier initials learned from user corrections
  learnedSupplierInitials Json? // Map of supplier names to their initials arrays
  // Format: { "Levic": ["L", "Lev", "Levi"], "Center": ["C", "Cent"] }

  status String @default("IN_PROGRESS") // "IN_PROGRESS", "COMPLETED", "CANCELLED"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  batches ExtractionBatch[]

  @@index([cutoverId])
  @@index([status])
}

model ExtractionBatch {
  id                  String   @id @default(uuid())
  extractionSessionId String // Links to extraction session
  batchNumber         Int // Sequential batch number (1, 2, 3, ...)
  cutoverId           String? // Optional link to cutover
  locationIds         String[] // Array of location IDs

  // Batch status
  status      String    @default("EXTRACTED") // "EXTRACTED", "APPROVED", "REJECTED"
  extractedAt DateTime  @default(now())
  approvedAt  DateTime?
  approvedBy  String? // User ID

  // Product tracking
  productIds                   String[] // Array of product IDs in this batch
  totalProducts                Int
  productsWithExtraction       Int
  productsRequiringManualInput Int

  // Approval tracking
  extractionApproved  Boolean @default(false) // Checkbox for extraction approval
  manualInputApproved Boolean @default(false) // Checkbox for manual input approval
  isFullyApproved     Boolean @default(false) // Both checkboxes must be true

  // Last approved item tracking
  lastApprovedProductId String? // Last product ID that was approved in this batch

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  session   ExtractionSession @relation(fields: [extractionSessionId], references: [id])
  approvals CostApproval[]

  @@index([extractionSessionId])
  @@index([cutoverId])
  @@index([status])
}
