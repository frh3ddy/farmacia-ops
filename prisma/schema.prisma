generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model Location {
  id       String  @id @default(uuid())
  squareId String? @unique
  name     String
  address  String?
  isActive Boolean @default(true)

  inventories     Inventory[]
  expenses        Expense[]
  sales           Sale[]
  racks           Rack[]
  catalogMappings CatalogMapping[]
  cutoverLocks    CutoverLock[]

  createdAt DateTime @default(now())
}

model User {
  id   String   @id @default(uuid())
  role UserRole @default(OWNER)

  createdAt DateTime @default(now())
}

enum UserRole {
  OWNER
}

model Product {
  id         String  @id @default(uuid())
  name       String
  sku        String? @unique
  categoryId String?

  // Square catalog data (cached to avoid API calls during extraction)
  squareProductName   String? // Product name from Square ITEM
  squareDescription   String? // Product description from Square ITEM
  squareImageUrl      String? // Product image URL from Square
  squareVariationName String? // Variation name from Square
  squareDataSyncedAt  DateTime? // When Square data was last synced

  category            Category?             @relation(fields: [categoryId], references: [id])
  suppliers           SupplierProduct[]
  supplierCostHistory SupplierCostHistory[]
  inventories         Inventory[]
  placements          Placement[]
  saleItems           SaleItem[]
  catalogMappings     CatalogMapping[]
  costApprovals       CostApproval[]

  createdAt DateTime @default(now())
}

model Category {
  id   String @id @default(uuid())
  name String

  products Product[]
}

model Supplier {
  id          String   @id @default(uuid())
  name        String
  initials    String? // Abbreviation or initials for cost extraction (e.g., "L" for "Levi")
  contactInfo String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  products    SupplierProduct[]
  costHistory SupplierCostHistory[]
}

model SupplierProduct {
  id         String @id @default(uuid())
  supplierId String
  productId  String

  cost        Decimal
  isPreferred Boolean @default(false)
  notes       String?

  supplier Supplier @relation(fields: [supplierId], references: [id])
  product  Product  @relation(fields: [productId], references: [id])

  @@unique([supplierId, productId])
}

model Inventory {
  id         String @id @default(uuid())
  locationId String
  productId  String

  quantity    Int
  receivedAt  DateTime
  unitCost    Decimal
  source      String? // "OPENING_BALANCE", "PURCHASE", "ADJUSTMENT"
  costSource  String? // "SQUARE_COST", "DESCRIPTION", "MANUAL_INPUT", "AVERAGE_COST"
  migrationId String? // Reference to cutover

  location Location @relation(fields: [locationId], references: [id])
  product  Product  @relation(fields: [productId], references: [id])

  createdAt DateTime @default(now())
}

model Sale {
  id         String @id @default(uuid())
  squareId   String @unique
  locationId String

  totalRevenue Decimal
  totalCost    Decimal
  grossProfit  Decimal

  createdAt DateTime

  items SaleItem[]

  location Location @relation(fields: [locationId], references: [id])
}

model SaleItem {
  id        String @id @default(uuid())
  saleId    String
  productId String

  quantity Int
  price    Decimal
  cost     Decimal

  sale    Sale    @relation(fields: [saleId], references: [id])
  product Product @relation(fields: [productId], references: [id])
}

model Expense {
  id         String @id @default(uuid())
  locationId String

  type   ExpenseType
  amount Decimal
  date   DateTime

  location Location @relation(fields: [locationId], references: [id])
}

enum ExpenseType {
  RENT
  UTILITIES
  PAYROLL
  OTHER
}

model Rack {
  id         String @id @default(uuid())
  locationId String
  name       String

  sections RackSection[]

  location Location @relation(fields: [locationId], references: [id])
}

model RackSection {
  id     String @id @default(uuid())
  rackId String
  label  String
  size   String

  placements Placement[]

  rack Rack @relation(fields: [rackId], references: [id])
}

model Placement {
  id            String @id @default(uuid())
  productId     String
  rackSectionId String

  product Product     @relation(fields: [productId], references: [id])
  section RackSection @relation(fields: [rackSectionId], references: [id])
}

model DemandSignal {
  id         String @id @default(uuid())
  query      String
  locationId String

  count Int @default(1)

  createdAt DateTime @default(now())
}

model CatalogMapping {
  id                String  @id @default(uuid())
  squareVariationId String // ITEM_VARIATION.id from Square
  productId         String
  locationId        String? // Optional, null = global mapping

  product  Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
  location Location? @relation(fields: [locationId], references: [id], onDelete: Cascade)

  syncedAt  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([squareVariationId, locationId]) // Unique per variation+location combination
  @@index([productId])
  @@index([locationId])
  @@index([squareVariationId])
}

model CostApproval {
  id           String   @id @default(uuid())
  cutoverId    String
  productId    String
  approvedCost Decimal
  source       String // "EXTRACTED_LAST", "EXTRACTED_SELECTED", "MANUAL_OVERRIDE"
  notes        String?
  approvedAt   DateTime @default(now())
  approvedBy   String? // User ID

  product Product @relation(fields: [productId], references: [id])

  @@unique([cutoverId, productId])
  @@index([cutoverId])
}

model Cutover {
  id              String    @id @default(uuid())
  cutoverDate     DateTime
  costBasis       String
  ownerApproved   Boolean
  ownerApprovedAt DateTime?
  ownerApprovedBy String?
  completedAt     DateTime?
  status          String // "PENDING", "COMPLETED", "FAILED", "IN_PROGRESS"
  result          Json? // Store MigrationResult
  batchSize       Int? // Number of items per batch
  currentBatch    Int? // Current batch being processed
  totalBatches    Int? // Total number of batches
  processedItems  Int? // Number of items processed so far
  totalItems      Int? // Total items to process
  batchState      Json? // Store state for resuming batches (processed product IDs, etc.)
  createdAt       DateTime  @default(now())
}

model CutoverLock {
  id          String   @id @default(uuid())
  locationId  String?
  cutoverDate DateTime
  isLocked    Boolean  @default(true)
  lockedAt    DateTime @default(now())
  lockedBy    String?

  location Location? @relation(fields: [locationId], references: [id])
}

model SupplierCostHistory {
  id          String   @id @default(uuid())
  productId   String
  supplierId  String
  unitCost    Decimal
  effectiveAt DateTime
  source      String // "MIGRATION" | "INVENTORY_UPDATE" | "MANUAL"
  isCurrent   Boolean  @default(true)
  createdAt   DateTime @default(now())

  product  Product  @relation(fields: [productId], references: [id])
  supplier Supplier @relation(fields: [supplierId], references: [id])

  @@index([productId, supplierId])
  @@index([isCurrent])
}
