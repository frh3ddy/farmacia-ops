<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Farmacia Ops - Kitchen Sink</title>
  <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet"/>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"/>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#007bff',
            'primary-hover': '#0056b3',
          }
        }
      }
    }
  </script>
  <style>
    body { font-family: 'Inter', sans-serif; }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f5f5f5;
      padding: 20px;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      padding: 20px;
    }
    h1 {
      color: #333;
      margin-bottom: 30px;
      border-bottom: 2px solid #007bff;
      padding-bottom: 10px;
    }
    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      border-bottom: 2px solid #e0e0e0;
    }
    .tab {
      padding: 10px 20px;
      cursor: pointer;
      border: none;
      background: none;
      font-size: 16px;
      color: #666;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }
    .tab:hover {
      color: #007bff;
    }
    .tab.active {
      color: #007bff;
      border-bottom-color: #007bff;
      font-weight: 600;
    }
    .content {
      margin-top: 20px;
    }
    .form-group {
      margin-bottom: 15px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
      color: #333;
    }
    input[type="text"],
    input[type="number"],
    textarea {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    textarea {
      min-height: 150px;
      font-family: monospace;
    }
    input[type="checkbox"] {
      margin-right: 8px;
    }
    button {
      padding: 10px 20px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: background 0.2s;
    }
    button:hover {
      background: #0056b3;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .btn-secondary {
      background: #6c757d;
    }
    .btn-secondary:hover {
      background: #545b62;
    }
    .loading {
      text-align: center;
      padding: 20px;
      color: #666;
    }
    .error {
      background: #f8d7da;
      color: #721c24;
      padding: 12px;
      border-radius: 4px;
      margin-bottom: 15px;
    }
    .success {
      background: #d4edda;
      color: #155724;
      padding: 12px;
      border-radius: 4px;
      margin-bottom: 15px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
    }
    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }
    th {
      background: #f8f9fa;
      font-weight: 600;
      color: #333;
    }
    tr:hover {
      background: #f8f9fa;
    }
    .badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
    }
    .badge-success {
      background: #d4edda;
      color: #155724;
    }
    .badge-danger {
      background: #f8d7da;
      color: #721c24;
    }
    .badge-info {
      background: #d1ecf1;
      color: #0c5460;
    }
    .expandable {
      cursor: pointer;
    }
    .details {
      padding: 15px;
      background: #f8f9fa;
      margin-top: 10px;
      border-radius: 4px;
    }
    .json-view {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      font-family: monospace;
      font-size: 12px;
      white-space: pre-wrap;
    }
    .sub-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    .sub-tab {
      padding: 8px 16px;
      cursor: pointer;
      border: 1px solid #ddd;
      background: white;
      font-size: 14px;
      color: #666;
      border-radius: 4px;
      transition: all 0.2s;
    }
    .sub-tab:hover {
      border-color: #007bff;
      color: #007bff;
    }
    .sub-tab.active {
      background: #007bff;
      color: white;
      border-color: #007bff;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    .stat-card {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 4px;
      border-left: 4px solid #007bff;
    }
    .stat-card h4 {
      margin: 0 0 8px 0;
      color: #666;
      font-size: 12px;
      text-transform: uppercase;
    }
    .stat-card .value {
      font-size: 24px;
      font-weight: 600;
      color: #333;
    }
    .risk-badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .risk-low {
      background: #d4edda;
      color: #155724;
    }
    .risk-medium {
      background: #fff3cd;
      color: #856404;
    }
    .risk-high {
      background: #f8d7da;
      color: #721c24;
    }
    .risk-critical {
      background: #721c24;
      color: white;
    }
    .progress-bar {
      height: 8px;
      background: #e0e0e0;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 5px;
    }
    .progress-fill {
      height: 100%;
      background: #007bff;
      transition: width 0.3s;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- Load InventoryMigration components in dependency order -->
  <script type="text/babel" src="components/InventoryMigration/utils/apiHelpers.jsx"></script>
  <script type="text/babel" src="components/InventoryMigration/utils/supplierUtils.jsx"></script>
  <script type="text/babel" src="components/InventoryMigration/hooks/useInventoryMigrationState.jsx"></script>
  <script type="text/babel" src="components/InventoryMigration/hooks/useSupplierMatching.jsx"></script>
  <script type="text/babel" src="components/InventoryMigration/hooks/useExtractionSession.jsx"></script>
  <script type="text/babel" src="components/InventoryMigration/components/SessionSelector.jsx"></script>
  <script type="text/babel" src="components/InventoryMigration/components/BatchCompleteModal.jsx"></script>
  <script type="text/babel" src="components/InventoryMigration/components/SupplierInitialsDisplay.jsx"></script>
  <script type="text/babel" src="components/InventoryMigration/components/ExtractionItemEditor.jsx"></script>
  <script type="text/babel" src="components/InventoryMigration/components/ApprovedItemEditor.jsx"></script>
  <script type="text/babel" src="components/InventoryMigration/components/SkippedItemEditor.jsx"></script>
  <script type="text/babel" src="components/InventoryMigration/phases/ConfigurationPhase.jsx"></script>
  <script type="text/babel" src="components/InventoryMigration/phases/ExtractionPhase.jsx"></script>
  <script type="text/babel" src="components/InventoryMigration/phases/ReviewPhase.jsx"></script>
  <script type="text/babel" src="components/InventoryMigration/phases/MigrationPhase.jsx"></script>
  <script type="text/babel" src="components/InventoryMigration/phases/ReportPhase.jsx"></script>
  <script type="text/babel" src="components/InventoryMigration/index.jsx"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    function App() {
      const [activeTab, setActiveTab] = useState('catalog-sync');

      return (
        <div className="max-w-7xl mx-auto bg-white rounded-xl shadow-sm p-6">
          <h1 className="text-3xl font-bold text-gray-900 mb-6 pb-3 border-b-2 border-primary">üß™ Farmacia Ops - Kitchen Sink</h1>
          <div className="flex gap-2 mb-6 border-b-2 border-gray-200">
            <button 
              className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors ${
                activeTab === 'catalog-sync' 
                  ? 'border-primary text-primary font-semibold' 
                  : 'border-transparent text-gray-600 hover:text-primary'
              }`}
              onClick={() => setActiveTab('catalog-sync')}
            >
              Catalog Sync
            </button>
            <button 
              className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors ${
                activeTab === 'mappings' 
                  ? 'border-primary text-primary font-semibold' 
                  : 'border-transparent text-gray-600 hover:text-primary'
              }`}
              onClick={() => setActiveTab('mappings')}
            >
              Catalog Mappings
            </button>
            <button 
              className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors ${
                activeTab === 'products' 
                  ? 'border-primary text-primary font-semibold' 
                  : 'border-transparent text-gray-600 hover:text-primary'
              }`}
              onClick={() => setActiveTab('products')}
            >
              Products
            </button>
            <button 
              className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors ${
                activeTab === 'sales' 
                  ? 'border-primary text-primary font-semibold' 
                  : 'border-transparent text-gray-600 hover:text-primary'
              }`}
              onClick={() => setActiveTab('sales')}
            >
              Sales
            </button>
            <button 
              className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors ${
                activeTab === 'locations' 
                  ? 'border-primary text-primary font-semibold' 
                  : 'border-transparent text-gray-600 hover:text-primary'
              }`}
              onClick={() => setActiveTab('locations')}
            >
              Locations
            </button>
            <button 
              className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors ${
                activeTab === 'webhook-test' 
                  ? 'border-primary text-primary font-semibold' 
                  : 'border-transparent text-gray-600 hover:text-primary'
              }`}
              onClick={() => setActiveTab('webhook-test')}
            >
              Webhook Test
            </button>
            <button 
              className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors ${
                activeTab === 'inventory' 
                  ? 'border-primary text-primary font-semibold' 
                  : 'border-transparent text-gray-600 hover:text-primary'
              }`}
              onClick={() => setActiveTab('inventory')}
            >
              Inventory
            </button>
            <button 
              className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors ${
                activeTab === 'inventory-aging' 
                  ? 'border-primary text-primary font-semibold' 
                  : 'border-transparent text-gray-600 hover:text-primary'
              }`}
              onClick={() => setActiveTab('inventory-aging')}
            >
              Inventory Aging
            </button>
            <button 
              className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors ${
                activeTab === 'inventory-migration' 
                  ? 'border-primary text-primary font-semibold' 
                  : 'border-transparent text-gray-600 hover:text-primary'
              }`}
              onClick={() => setActiveTab('inventory-migration')}
            >
              Inventory Migration
            </button>
            <button 
              className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors ${
                activeTab === 'suppliers' 
                  ? 'border-primary text-primary font-semibold' 
                  : 'border-transparent text-gray-600 hover:text-primary'
              }`}
              onClick={() => setActiveTab('suppliers')}
            >
              Suppliers
            </button>
          </div>
          <div className="mt-6">
            {activeTab === 'catalog-sync' && <CatalogSync />}
            {activeTab === 'mappings' && <CatalogMappings />}
            {activeTab === 'products' && <Products />}
            {activeTab === 'sales' && <Sales />}
            {activeTab === 'locations' && <Locations />}
            {activeTab === 'webhook-test' && <WebhookTest />}
            {activeTab === 'inventory' && <Inventory />}
            {activeTab === 'inventory-aging' && <InventoryAging />}
            {activeTab === 'inventory-migration' && <InventoryMigration />}
            {activeTab === 'suppliers' && <Suppliers />}
          </div>
        </div>
      );
    }

    function CatalogSync() {
      const [locationId, setLocationId] = useState('');
      const [forceResync, setForceResync] = useState(false);
      const [loading, setLoading] = useState(false);
      const [result, setResult] = useState(null);
      const [error, setError] = useState(null);
      const [cleaningUp, setCleaningUp] = useState(false);
      const [cleanupResult, setCleanupResult] = useState(null);

      const handleCleanup = async () => {
        if (!confirm('This will delete all catalog mappings and ALL products. Are you sure? This cannot be undone!')) {
          return;
        }

        setCleaningUp(true);
        setError(null);
        setCleanupResult(null);

        try {
          const response = await fetch('/api/catalog/cleanup', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ deleteProducts: true }),
          });

          const data = await response.json();
          if (response.ok) {
            setCleanupResult(data);
            // Clear sync result since mappings are gone
            setResult(null);
          } else {
            setError(data.message || 'Cleanup failed');
          }
        } catch (err) {
          setError(err.message || 'Failed to cleanup catalog');
        } finally {
          setCleaningUp(false);
        }
      };

      const handleSync = async () => {
        setLoading(true);
        setError(null);
        setResult(null);

        try {
          const response = await fetch('/admin/square/catalog/sync', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              locationId: locationId || null,
              forceResync,
            }),
          });

          const data = await response.json();
          if (response.ok) {
            setResult(data);
          } else {
            setError(data.message || 'Sync failed');
          }
        } catch (err) {
          setError(err.message || 'Failed to sync catalog');
        } finally {
          setLoading(false);
        }
      };

      return (
        <div>
          <h2>Catalog Sync</h2>
          <div style={{ marginBottom: '20px', padding: '15px', background: '#fff3cd', border: '1px solid #ffc107', borderRadius: '4px' }}>
            <strong>‚ö†Ô∏è Cleanup Option:</strong> Use the cleanup button below to delete ALL related records (cost approvals, catalog mappings, supplier products, cost history, inventory, sale items, placements) and ALL products to start completely fresh. This will remove all products and their relationships from the database.
          </div>
          <div style={{ marginBottom: '20px' }}>
            <button 
              onClick={handleCleanup} 
              disabled={cleaningUp}
              style={{ 
                background: cleaningUp ? '#6c757d' : '#dc3545', 
                color: 'white',
                padding: '10px 20px',
                border: 'none',
                borderRadius: '4px',
                cursor: cleaningUp ? 'not-allowed' : 'pointer',
                marginRight: '10px'
              }}
            >
              {cleaningUp ? 'Cleaning Up...' : 'üßπ Cleanup Catalog (Delete Mappings & Clear Square Data)'}
            </button>
            {cleanupResult && (
              <div className="success" style={{ marginTop: '10px' }}>
                <strong>Cleanup Complete:</strong> Deleted {cleanupResult.data?.costApprovalsDeleted || 0} cost approvals, {cleanupResult.data?.mappingsDeleted || 0} mappings, {cleanupResult.data?.supplierProductsDeleted || 0} supplier products, {cleanupResult.data?.costHistoryDeleted || 0} cost history records, {cleanupResult.data?.inventoryDeleted || 0} inventory records, {cleanupResult.data?.saleItemsDeleted || 0} sale items, {cleanupResult.data?.placementsDeleted || 0} placements, {cleanupResult.data?.productsDeleted || 0} products deleted, {cleanupResult.data?.productsUpdated || 0} products updated
              </div>
            )}
          </div>
          <div className="form-group">
            <label>Location ID (optional):</label>
            <input
              type="text"
              value={locationId}
              onChange={(e) => setLocationId(e.target.value)}
              placeholder="Leave empty for global sync"
            />
          </div>
          <div className="form-group">
            <label>
              <input
                type="checkbox"
                checked={forceResync}
                onChange={(e) => setForceResync(e.target.checked)}
              />
              Force Resync (re-sync existing mappings)
            </label>
          </div>
          <button onClick={handleSync} disabled={loading}>
            {loading ? 'Syncing...' : 'Sync Catalog'}
          </button>

          {error && <div className="error">{error}</div>}
          {result && (
            <div className="success">
              <h3>Sync Results</h3>
              <p><strong>Total Variations Found:</strong> {result.result?.totalVariationsFound || 0}</p>
              <p><strong>Variations Processed:</strong> {result.result?.variationsProcessed || 0}</p>
              <p><strong>Products Created:</strong> {result.result?.productsCreated || 0}</p>
              <p><strong>Mappings Created:</strong> {result.result?.mappingsCreated || 0}</p>
              <p><strong>Mappings Skipped:</strong> {result.result?.mappingsSkipped || 0}</p>
              {result.result?.errors?.length > 0 && (
                <div>
                  <strong>Errors:</strong>
                  <ul>
                    {result.result.errors.map((err, i) => (
                      <li key={i}>{err.variationName}: {err.error}</li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          )}
        </div>
      );
    }

    function CatalogMappings() {
      const [mappings, setMappings] = useState([]);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);

      const fetchMappings = async () => {
        setLoading(true);
        setError(null);
        try {
          const response = await fetch('/api/catalog/mappings');
          const data = await response.json();
          if (data.success) {
            setMappings(data.data || []);
          } else {
            setError('Failed to fetch mappings');
          }
        } catch (err) {
          setError(err.message || 'Failed to fetch mappings');
        } finally {
          setLoading(false);
        }
      };

      useEffect(() => {
        fetchMappings();
      }, []);

      if (loading) return <div className="loading">Loading mappings...</div>;
      if (error) return <div className="error">{error}</div>;

      return (
        <div>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <h2>Catalog Mappings ({mappings.length})</h2>
            <button onClick={fetchMappings} className="btn-secondary">Refresh</button>
          </div>
          <table>
            <thead>
              <tr>
                <th>Variation ID</th>
                <th>Product</th>
                <th>Location</th>
                <th>Synced At</th>
              </tr>
            </thead>
            <tbody>
              {mappings.map((mapping) => (
                <tr key={mapping.id}>
                  <td><code>{mapping.squareVariationId}</code></td>
                  <td>{mapping.product?.name || 'N/A'}</td>
                  <td>{mapping.location?.name || (mapping.locationId ? mapping.locationId : 'Global')}</td>
                  <td>{new Date(mapping.syncedAt).toLocaleString()}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }

    function Products() {
      const [products, setProducts] = useState([]);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);

      useEffect(() => {
        fetch('/api/products')
          .then(res => res.json())
          .then(data => {
            if (data.success) {
              setProducts(data.data || []);
            } else {
              setError('Failed to fetch products');
            }
          })
          .catch(err => setError(err.message))
          .finally(() => setLoading(false));
      }, []);

      if (loading) return <div className="loading">Loading products...</div>;
      if (error) return <div className="error">{error}</div>;

      return (
        <div>
          <h2>Products ({products.length})</h2>
          <table>
            <thead>
              <tr>
                <th>ID</th>
                <th>Name</th>
                <th>Square Product Name</th>
                <th>SKU</th>
                <th>Category</th>
                <th>Mappings</th>
                <th>Created</th>
              </tr>
            </thead>
            <tbody>
              {products.map((product) => (
                <tr key={product.id}>
                  <td><code>{product.id.substring(0, 8)}...</code></td>
                  <td>{product.name}</td>
                  <td>{product.squareProductName || '-'}</td>
                  <td>{product.sku || '-'}</td>
                  <td>{product.category?.name || '-'}</td>
                  <td><span className="badge badge-info">{product.catalogMappings?.length || 0}</span></td>
                  <td>{new Date(product.createdAt).toLocaleDateString()}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }

    function Sales() {
      const [sales, setSales] = useState([]);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);
      const [expanded, setExpanded] = useState(new Set());

      useEffect(() => {
        fetch('/api/sales')
          .then(res => res.json())
          .then(data => {
            if (data.success) {
              setSales(data.data || []);
            } else {
              setError('Failed to fetch sales');
            }
          })
          .catch(err => setError(err.message))
          .finally(() => setLoading(false));
      }, []);

      const toggleExpand = (id) => {
        const newExpanded = new Set(expanded);
        if (newExpanded.has(id)) {
          newExpanded.delete(id);
        } else {
          newExpanded.add(id);
        }
        setExpanded(newExpanded);
      };

      if (loading) return <div className="loading">Loading sales...</div>;
      if (error) return <div className="error">{error}</div>;

      return (
        <div>
          <h2>Sales ({sales.length})</h2>
          <table>
            <thead>
              <tr>
                <th></th>
                <th>Square ID</th>
                <th>Location</th>
                <th>Revenue</th>
                <th>Cost</th>
                <th>Profit</th>
                <th>Items</th>
                <th>Created</th>
              </tr>
            </thead>
            <tbody>
              {sales.map((sale) => (
                <React.Fragment key={sale.id}>
                  <tr className="expandable" onClick={() => toggleExpand(sale.id)}>
                    <td>{expanded.has(sale.id) ? '‚ñº' : '‚ñ∂'}</td>
                    <td><code>{sale.squareId}</code></td>
                    <td>{sale.location?.name || sale.locationId}</td>
                    <td>${parseFloat(sale.totalRevenue).toFixed(2)}</td>
                    <td>${parseFloat(sale.totalCost).toFixed(2)}</td>
                    <td>${parseFloat(sale.grossProfit).toFixed(2)}</td>
                    <td>{sale.items?.length || 0}</td>
                    <td>{new Date(sale.createdAt).toLocaleString()}</td>
                  </tr>
                  {expanded.has(sale.id) && (
                    <tr>
                      <td colSpan="8">
                        <div className="details">
                          <h4>Sale Items:</h4>
                          <table>
                            <thead>
                              <tr>
                                <th>Product</th>
                                <th>Quantity</th>
                                <th>Price</th>
                                <th>Cost</th>
                              </tr>
                            </thead>
                            <tbody>
                              {sale.items?.map((item) => (
                                <tr key={item.id}>
                                  <td>{item.product?.name || 'N/A'}</td>
                                  <td>{item.quantity}</td>
                                  <td>${parseFloat(item.price).toFixed(2)}</td>
                                  <td>${parseFloat(item.cost).toFixed(2)}</td>
                                </tr>
                              ))}
                            </tbody>
                          </table>
                        </div>
                      </td>
                    </tr>
                  )}
                </React.Fragment>
              ))}
            </tbody>
          </table>
        </div>
      );
    }

    function Locations() {
      const [locations, setLocations] = useState([]);
      const [loadingLocations, setLoadingLocations] = useState(true);
      const [error, setError] = useState(null);

      const fetchLocations = async () => {
        setLoadingLocations(true);
        setError(null);
        try {
          const response = await fetch('/locations');
          const data = await response.json();
          if (data.success) {
            setLocations(data.data || []);
          } else {
            setError(data.message || 'Failed to fetch locations');
          }
        } catch (err) {
          setError(err.message || 'Failed to fetch locations');
          console.error('Failed to fetch locations:', err);
        } finally {
          setLoadingLocations(false);
        }
      };

      const syncLocationsFromSquare = async () => {
        setLoadingLocations(true);
        setError(null);
        try {
          const response = await fetch('/locations/sync', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
          });
          const data = await response.json();
          if (data.success) {
            // Refresh locations after sync
            await fetchLocations();
            alert(`Successfully synced locations: ${data.result.created} created, ${data.result.updated} updated`);
          } else {
            setError(data.message || 'Failed to sync locations from Square');
          }
        } catch (err) {
          setError(err.message || 'Failed to sync locations from Square');
          console.error('Failed to sync locations:', err);
        } finally {
          setLoadingLocations(false);
        }
      };

      useEffect(() => {
        fetchLocations();
      }, []);

      if (loadingLocations && locations.length === 0) return <div className="loading">Loading locations...</div>;
      if (error && locations.length === 0) return <div className="error">{error}</div>;

      return (
        <div>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>
            <h2>Locations ({locations.length})</h2>
            <div style={{ display: 'flex', gap: '10px' }}>
              <button 
                onClick={syncLocationsFromSquare} 
                disabled={loadingLocations}
                className="px-4 py-2 bg-green-600 hover:bg-green-700 text-white text-sm font-medium rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {loadingLocations ? 'Syncing...' : 'Sync from Square'}
              </button>
              <button 
                onClick={fetchLocations} 
                disabled={loadingLocations}
                className="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white text-sm font-medium rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {loadingLocations ? 'Loading...' : 'Refresh'}
              </button>
            </div>
          </div>
          {error && <div className="error">{error}</div>}
          <table>
            <thead>
              <tr>
                <th>ID</th>
                <th>Name</th>
                <th>Address</th>
                <th>Status</th>
                <th>Created</th>
              </tr>
            </thead>
            <tbody>
              {locations.map((location) => (
                <tr key={location.id}>
                  <td><code>{location.id.substring(0, 8)}...</code></td>
                  <td>{location.name}</td>
                  <td>{location.address || '-'}</td>
                  <td>
                    <span className={`badge ${location.isActive ? 'badge-success' : 'badge-danger'}`}>
                      {location.isActive ? 'Active' : 'Inactive'}
                    </span>
                  </td>
                  <td>{new Date(location.createdAt).toLocaleDateString()}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }

    function WebhookTest() {
      const [paymentId, setPaymentId] = useState('');
      const [orderId, setOrderId] = useState('');
      const [locationId, setLocationId] = useState('L60AMVPDZJ48F');
      const [amount, setAmount] = useState(100);
      const [loading, setLoading] = useState(false);
      const [result, setResult] = useState(null);
      const [error, setError] = useState(null);
      const [isPaused, setIsPaused] = useState(false);
      const [statusLoading, setStatusLoading] = useState(true);

      useEffect(() => {
        // Fetch initial status
        fetchStatus();
      }, []);

      const fetchStatus = async () => {
        try {
          const response = await fetch('/api/webhooks/square/test/status');
          const data = await response.json();
          if (data.success) {
            setIsPaused(data.paused || false);
          }
        } catch (err) {
          console.error('Failed to fetch webhook status:', err);
        } finally {
          setStatusLoading(false);
        }
      };

      const handlePause = async () => {
        try {
          const response = await fetch('/api/webhooks/square/test/pause', {
            method: 'POST',
          });
          const data = await response.json();
          if (data.success) {
            setIsPaused(true);
          }
        } catch (err) {
          setError(err.message || 'Failed to pause webhook testing');
        }
      };

      const handleResume = async () => {
        try {
          const response = await fetch('/api/webhooks/square/test/resume', {
            method: 'POST',
          });
          const data = await response.json();
          if (data.success) {
            setIsPaused(false);
          }
        } catch (err) {
          setError(err.message || 'Failed to resume webhook testing');
        }
      };

      const handleTest = async () => {
        if (isPaused) {
          setError('Webhook testing is paused. Please resume to send test webhooks.');
          return;
        }

        setLoading(true);
        setError(null);
        setResult(null);

        try {
          const response = await fetch('/api/webhooks/square/test', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              paymentId: paymentId || undefined,
              orderId: orderId || undefined,
              locationId,
              amount,
            }),
          });

          const data = await response.json();
          if (data.success) {
            setResult(data);
          } else {
            setError(data.message || 'Webhook test failed');
            if (data.paused) {
              setIsPaused(true);
            }
          }
        } catch (err) {
          setError(err.message || 'Failed to test webhook');
        } finally {
          setLoading(false);
        }
      };

      return (
        <div>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>
            <h2>Test Webhook</h2>
            {!statusLoading && (
              <div style={{ display: 'flex', gap: '10px', alignItems: 'center' }}>
                <span style={{ 
                  padding: '5px 15px', 
                  background: isPaused ? '#dc3545' : '#28a745', 
                  color: 'white', 
                  borderRadius: '4px',
                  fontWeight: '600'
                }}>
                  {isPaused ? '‚è∏ PAUSED' : '‚ñ∂ ACTIVE'}
                </span>
                {isPaused ? (
                  <button onClick={handleResume} style={{ background: '#28a745' }}>
                    Resume
                  </button>
                ) : (
                  <button onClick={handlePause} style={{ background: '#dc3545' }}>
                    Pause
                  </button>
                )}
              </div>
            )}
          </div>
          <p style={{ marginBottom: '15px', color: '#666' }}>
            Simulate a Square payment webhook to test sale processing.
            {isPaused && <strong style={{ color: '#dc3545', display: 'block', marginTop: '5px' }}>‚ö†Ô∏è Webhook testing is paused. Jobs will not be sent.</strong>}
          </p>
          <div className="form-group">
            <label>Payment ID (optional, auto-generated if empty):</label>
            <input
              type="text"
              value={paymentId}
              onChange={(e) => setPaymentId(e.target.value)}
              placeholder="test_payment_123"
            />
          </div>
          <div className="form-group">
            <label>Order ID (optional, auto-generated if empty):</label>
            <input
              type="text"
              value={orderId}
              onChange={(e) => setOrderId(e.target.value)}
              placeholder="test_order_123"
            />
          </div>
          <div className="form-group">
            <label>Location ID:</label>
            <input
              type="text"
              value={locationId}
              onChange={(e) => setLocationId(e.target.value)}
              required
            />
          </div>
          <div className="form-group">
            <label>Amount (cents):</label>
            <input
              type="number"
              value={amount}
              onChange={(e) => setAmount(parseInt(e.target.value) || 0)}
              min="1"
            />
          </div>
          <button onClick={handleTest} disabled={loading || isPaused}>
            {loading ? 'Sending...' : isPaused ? 'Paused - Cannot Send' : 'Send Test Webhook'}
          </button>

          {error && <div className="error">{error}</div>}
          {result && (
            <div className="success">
              <h3>Webhook Test Result</h3>
              <p><strong>Status:</strong> {result.message}</p>
              <p><strong>Event ID:</strong> {result.eventId}</p>
              <p style={{ marginTop: '10px' }}>Check the worker logs to see if the sale was processed.</p>
            </div>
          )}
        </div>
      );
    }

    function Inventory() {
      const [inventory, setInventory] = useState([]);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);
      const [creating, setCreating] = useState(false);
      const [createResult, setCreateResult] = useState(null);

      const fetchInventory = () => {
        setLoading(true);
        setError(null);
        fetch('/api/inventory')
          .then(res => res.json())
          .then(data => {
            if (data.success) {
              setInventory(data.data || []);
            } else {
              setError('Failed to fetch inventory');
            }
          })
          .catch(err => setError(err.message))
          .finally(() => setLoading(false));
      };

      useEffect(() => {
        fetchInventory();
      }, []);

      const handleCreateTestInventory = async () => {
        setCreating(true);
        setError(null);
        setCreateResult(null);

        try {
          // Include the specified product variation ID
          const response = await fetch('/api/inventory/test', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              squareVariationIds: ['YWASJW42SCO2V6MSXMTI55H5'], // The specified product
            }),
          });

          const data = await response.json();
          if (data.success) {
            setCreateResult(data);
            // Refresh inventory list
            fetchInventory();
          } else {
            setError(data.message || 'Failed to create test inventory');
          }
        } catch (err) {
          setError(err.message || 'Failed to create test inventory');
        } finally {
          setCreating(false);
        }
      };

      if (loading) return <div className="loading">Loading inventory...</div>;
      if (error) return <div className="error">{error}</div>;

      // Group inventory by product and location for better display
      const grouped = inventory.reduce((acc, item) => {
        const key = `${item.productId}-${item.locationId}`;
        if (!acc[key]) {
          acc[key] = {
            product: item.product,
            location: item.location,
            items: [],
            totalQuantity: 0,
          };
        }
        acc[key].items.push(item);
        acc[key].totalQuantity += item.quantity;
        return acc;
      }, {});

      return (
        <div>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>
            <h2>Inventory ({inventory.length} batches)</h2>
            <div style={{ display: 'flex', gap: '10px' }}>
              <button 
                onClick={handleCreateTestInventory} 
                disabled={creating}
                style={{ background: '#28a745' }}
              >
                {creating ? 'Creating...' : 'Pull Test Inventory'}
              </button>
              <button onClick={fetchInventory} className="btn-secondary">Refresh</button>
            </div>
          </div>
          
          {error && <div className="error">{error}</div>}
          {createResult && (
            <div className="success">
              <strong>Success!</strong> {createResult.message}
              <br />
              Created {createResult.count} inventory batch(es)
            </div>
          )}
          
          <div style={{ marginBottom: '20px', padding: '15px', background: '#f8f9fa', borderRadius: '4px' }}>
            <strong>Note:</strong> This is for testing purposes. A full inventory management feature will be added later.
            <br />
            <strong>Total Unique Products:</strong> {Object.keys(grouped).length}
            <br />
            <strong>Pull Test Inventory:</strong> Creates test inventory batches (100 units @ $5.00 each) for the specified Square variation ID and other products.
          </div>

          <h3>By Product & Location</h3>
          <table>
            <thead>
              <tr>
                <th>Product</th>
                <th>Location</th>
                <th>Total Qty</th>
                <th>Batches</th>
              </tr>
            </thead>
            <tbody>
              {Object.values(grouped).map((group, idx) => (
                <tr key={idx}>
                  <td>{group.product?.name || 'N/A'}</td>
                  <td>{group.location?.name || group.location?.squareId || 'N/A'}</td>
                  <td><strong>{group.totalQuantity}</strong></td>
                  <td>{group.items.length}</td>
                </tr>
              ))}
            </tbody>
          </table>

          <h3 style={{ marginTop: '30px' }}>All Inventory Batches (FIFO Order)</h3>
          <table>
            <thead>
              <tr>
                <th>Product</th>
                <th>Location</th>
                <th>Quantity</th>
                <th>Unit Cost</th>
                <th>Total Cost</th>
                <th>Received At</th>
                <th>Created</th>
              </tr>
            </thead>
            <tbody>
              {inventory.map((item) => (
                <tr key={item.id}>
                  <td>{item.product?.name || 'N/A'}</td>
                  <td>{item.location?.name || item.location?.squareId || 'N/A'}</td>
                  <td><strong>{item.quantity}</strong></td>
                  <td>${parseFloat(item.unitCost).toFixed(2)}</td>
                  <td>${(parseFloat(item.unitCost) * item.quantity).toFixed(2)}</td>
                  <td>{new Date(item.receivedAt).toLocaleDateString()}</td>
                  <td>{new Date(item.createdAt).toLocaleDateString()}</td>
                </tr>
              ))}
            </tbody>
          </table>
          {inventory.length === 0 && (
            <div style={{ textAlign: 'center', padding: '40px', color: '#666' }}>
              No inventory records found. Create inventory batches to track stock.
            </div>
          )}
        </div>
      );
    }

    function InventoryAging() {
      const [activeView, setActiveView] = useState('summary');
      const [summary, setSummary] = useState(null);
      const [products, setProducts] = useState([]);
      const [locations, setLocations] = useState([]);
      const [categories, setCategories] = useState([]);
      const [signals, setSignals] = useState([]);
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState(null);
      
      // Filters
      const [locationId, setLocationId] = useState('');
      const [categoryId, setCategoryId] = useState('');
      const [riskLevel, setRiskLevel] = useState('');
      const [severity, setSeverity] = useState('');
      const [signalType, setSignalType] = useState('');
      const [limit, setLimit] = useState('100');
      const [offset, setOffset] = useState('0');

      const fetchSummary = async () => {
        setLoading(true);
        setError(null);
        try {
          const params = new URLSearchParams();
          if (locationId && locationId.trim()) params.append('locationId', locationId.trim());
          if (categoryId && categoryId.trim()) params.append('categoryId', categoryId.trim());
          const response = await fetch(`/inventory/aging/summary?${params}`);
          const data = await response.json();
          if (response.ok) {
            setSummary(data);
          } else {
            setError(data.message || 'Failed to fetch summary');
          }
        } catch (err) {
          setError(err.message || 'Failed to fetch summary');
        } finally {
          setLoading(false);
        }
      };

      const fetchProducts = async () => {
        setLoading(true);
        setError(null);
        try {
          const params = new URLSearchParams();
          if (locationId && locationId.trim()) params.append('locationId', locationId.trim());
          if (categoryId && categoryId.trim()) params.append('categoryId', categoryId.trim());
          if (riskLevel && riskLevel.trim()) params.append('riskLevel', riskLevel.trim());
          if (limit && limit.trim()) params.append('limit', limit.trim());
          if (offset && offset.trim()) params.append('offset', offset.trim());
          const response = await fetch(`/inventory/aging/products?${params}`);
          const data = await response.json();
          if (response.ok) {
            setProducts(data.products || []);
          } else {
            setError(data.message || 'Failed to fetch products');
          }
        } catch (err) {
          setError(err.message || 'Failed to fetch products');
        } finally {
          setLoading(false);
        }
      };

      const fetchLocations = async () => {
        setLoading(true);
        setError(null);
        try {
          const params = new URLSearchParams();
          if (locationId && locationId.trim()) params.append('locationId', locationId.trim());
          const response = await fetch(`/inventory/aging/location?${params}`);
          const data = await response.json();
          if (response.ok) {
            setLocations(data.locations || []);
          } else {
            setError(data.message || 'Failed to fetch locations');
          }
        } catch (err) {
          setError(err.message || 'Failed to fetch locations');
        } finally {
          setLoading(false);
        }
      };

      const fetchCategories = async () => {
        setLoading(true);
        setError(null);
        try {
          const params = new URLSearchParams();
          if (categoryId && categoryId.trim()) params.append('categoryId', categoryId.trim());
          const response = await fetch(`/inventory/aging/category?${params}`);
          const data = await response.json();
          if (response.ok) {
            setCategories(data.categories || []);
          } else {
            setError(data.message || 'Failed to fetch categories');
          }
        } catch (err) {
          setError(err.message || 'Failed to fetch categories');
        } finally {
          setLoading(false);
        }
      };

      const fetchSignals = async () => {
        setLoading(true);
        setError(null);
        try {
          const params = new URLSearchParams();
          if (severity && severity.trim()) params.append('severity', severity.trim());
          if (signalType && signalType.trim()) params.append('type', signalType.trim());
          if (limit && limit.trim()) params.append('limit', limit.trim());
          const response = await fetch(`/inventory/aging/signals?${params}`);
          const data = await response.json();
          if (response.ok) {
            setSignals(data.signals || []);
          } else {
            setError(data.message || 'Failed to fetch signals');
          }
        } catch (err) {
          setError(err.message || 'Failed to fetch signals');
        } finally {
          setLoading(false);
        }
      };

      useEffect(() => {
        if (activeView === 'summary') fetchSummary();
        else if (activeView === 'products') fetchProducts();
        else if (activeView === 'locations') fetchLocations();
        else if (activeView === 'categories') fetchCategories();
        else if (activeView === 'signals') fetchSignals();
      }, [activeView, locationId, categoryId, riskLevel, severity, signalType, limit, offset]);

      const getRiskClass = (risk) => {
        const r = risk?.toLowerCase() || '';
        if (r === 'critical') return 'risk-critical';
        if (r === 'high') return 'risk-high';
        if (r === 'medium') return 'risk-medium';
        return 'risk-low';
      };

      return (
        <div>
          <h2>Inventory Aging Analysis</h2>
          <p style={{ marginBottom: '20px', color: '#666' }}>
            Analyze inventory aging to identify slow-moving products, cash tied up, and actionable insights.
          </p>

          <div className="sub-tabs">
            <button 
              className={`sub-tab ${activeView === 'summary' ? 'active' : ''}`}
              onClick={() => setActiveView('summary')}
            >
              Summary
            </button>
            <button 
              className={`sub-tab ${activeView === 'products' ? 'active' : ''}`}
              onClick={() => setActiveView('products')}
            >
              Products
            </button>
            <button 
              className={`sub-tab ${activeView === 'locations' ? 'active' : ''}`}
              onClick={() => setActiveView('locations')}
            >
              Locations
            </button>
            <button 
              className={`sub-tab ${activeView === 'categories' ? 'active' : ''}`}
              onClick={() => setActiveView('categories')}
            >
              Categories
            </button>
            <button 
              className={`sub-tab ${activeView === 'signals' ? 'active' : ''}`}
              onClick={() => setActiveView('signals')}
            >
              Actionable Signals
            </button>
          </div>

          <div style={{ marginBottom: '20px', padding: '15px', background: '#f8f9fa', borderRadius: '4px' }}>
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '10px' }}>
              <div>
                <label style={{ display: 'block', marginBottom: '5px', fontSize: '12px', fontWeight: '600' }}>Location ID:</label>
                <input
                  type="text"
                  value={locationId}
                  onChange={(e) => setLocationId(e.target.value)}
                  placeholder="Filter by location"
                  style={{ width: '100%', padding: '6px', fontSize: '12px' }}
                />
              </div>
              <div>
                <label style={{ display: 'block', marginBottom: '5px', fontSize: '12px', fontWeight: '600' }}>Category ID:</label>
                <input
                  type="text"
                  value={categoryId}
                  onChange={(e) => setCategoryId(e.target.value)}
                  placeholder="Filter by category"
                  style={{ width: '100%', padding: '6px', fontSize: '12px' }}
                />
              </div>
              {activeView === 'products' && (
                <div>
                  <label style={{ display: 'block', marginBottom: '5px', fontSize: '12px', fontWeight: '600' }}>Risk Level:</label>
                  <select
                    value={riskLevel}
                    onChange={(e) => setRiskLevel(e.target.value)}
                    style={{ width: '100%', padding: '6px', fontSize: '12px' }}
                  >
                    <option value="">All</option>
                    <option value="LOW">Low</option>
                    <option value="MEDIUM">Medium</option>
                    <option value="HIGH">High</option>
                    <option value="CRITICAL">Critical</option>
                  </select>
                </div>
              )}
              {activeView === 'signals' && (
                <>
                  <div>
                    <label style={{ display: 'block', marginBottom: '5px', fontSize: '12px', fontWeight: '600' }}>Severity:</label>
                    <select
                      value={severity}
                      onChange={(e) => setSeverity(e.target.value)}
                      style={{ width: '100%', padding: '6px', fontSize: '12px' }}
                    >
                      <option value="">All</option>
                      <option value="LOW">Low</option>
                      <option value="MEDIUM">Medium</option>
                      <option value="HIGH">High</option>
                      <option value="CRITICAL">Critical</option>
                    </select>
                  </div>
                  <div>
                    <label style={{ display: 'block', marginBottom: '5px', fontSize: '12px', fontWeight: '600' }}>Type:</label>
                    <select
                      value={signalType}
                      onChange={(e) => setSignalType(e.target.value)}
                      style={{ width: '100%', padding: '6px', fontSize: '12px' }}
                    >
                      <option value="">All</option>
                      <option value="AT_RISK">At Risk</option>
                      <option value="SLOW_MOVING_EXPENSIVE">Slow Moving Expensive</option>
                      <option value="OVERSTOCKED_CATEGORY">Overstocked Category</option>
                    </select>
                  </div>
                </>
              )}
              {(activeView === 'products' || activeView === 'signals') && (
                <div>
                  <label style={{ display: 'block', marginBottom: '5px', fontSize: '12px', fontWeight: '600' }}>Limit:</label>
                  <input
                    type="number"
                    value={limit}
                    onChange={(e) => setLimit(e.target.value)}
                    style={{ width: '100%', padding: '6px', fontSize: '12px' }}
                    min="1"
                    max="500"
                  />
                </div>
              )}
            </div>
          </div>

          {error && <div className="error">{error}</div>}

          {loading && <div className="loading">Loading...</div>}

          {activeView === 'summary' && summary && (
            <div>
              <div className="stats-grid">
                <div className="stat-card">
                  <h4>Total Cash Tied Up</h4>
                  <div className="value">${summary.totalCashTiedUp?.toFixed(2) || '0.00'}</div>
                </div>
                <div className="stat-card">
                  <h4>Total Units</h4>
                  <div className="value">{summary.totalUnits || 0}</div>
                </div>
              </div>
              <h3>Aging Buckets</h3>
              <table>
                <thead>
                  <tr>
                    <th>Age Range</th>
                    <th>Cash Value</th>
                    <th>Units</th>
                    <th>Percentage</th>
                    <th>Visual</th>
                  </tr>
                </thead>
                <tbody>
                  {summary.buckets?.map((bucket, idx) => (
                    <tr key={idx}>
                      <td><strong>{bucket.bucket?.label || 'N/A'}</strong></td>
                      <td>${bucket.cashValue?.toFixed(2) || '0.00'}</td>
                      <td>{bucket.unitCount || 0}</td>
                      <td>{bucket.percentageOfTotal?.toFixed(1) || '0.0'}%</td>
                      <td style={{ width: '200px' }}>
                        <div className="progress-bar">
                          <div 
                            className="progress-fill" 
                            style={{ width: `${bucket.percentageOfTotal || 0}%` }}
                          />
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}

          {activeView === 'products' && products.length > 0 && (
            <div>
              <h3>Product Aging Analysis ({products.length})</h3>
              <table>
                <thead>
                  <tr>
                    <th>Product</th>
                    <th>Category</th>
                    <th>Cash Tied Up</th>
                    <th>Units</th>
                    <th>Oldest Age (days)</th>
                    <th>Risk Level</th>
                    <th>Buckets</th>
                  </tr>
                </thead>
                <tbody>
                  {products.map((product) => (
                    <tr key={product.productId}>
                      <td><strong>{product.productName}</strong></td>
                      <td>{product.categoryName || '-'}</td>
                      <td>${product.totalCashTiedUp?.toFixed(2) || '0.00'}</td>
                      <td>{product.totalUnits || 0}</td>
                      <td>{product.oldestBatchAge || 0}</td>
                      <td>
                        <span className={`risk-badge ${getRiskClass(product.riskLevel)}`}>
                          {product.riskLevel || 'LOW'}
                        </span>
                      </td>
                      <td>
                        {product.bucketDistribution?.map((b, i) => (
                          <span key={i} style={{ marginRight: '5px', fontSize: '11px' }}>
                            {b.bucket?.label}: {b.percentageOfTotal?.toFixed(0)}%
                          </span>
                        ))}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}

          {activeView === 'locations' && locations.length > 0 && (
            <div>
              <h3>Location Aging Analysis ({locations.length})</h3>
              <table>
                <thead>
                  <tr>
                    <th>Location</th>
                    <th>Cash Tied Up</th>
                    <th>Units</th>
                    <th>At-Risk Products</th>
                    <th>Buckets</th>
                  </tr>
                </thead>
                <tbody>
                  {locations.map((location) => (
                    <tr key={location.locationId}>
                      <td><strong>{location.locationName}</strong></td>
                      <td>${location.totalCashTiedUp?.toFixed(2) || '0.00'}</td>
                      <td>{location.totalUnits || 0}</td>
                      <td>
                        <span className={location.atRiskProducts > 0 ? 'risk-badge risk-high' : 'risk-badge risk-low'}>
                          {location.atRiskProducts || 0}
                        </span>
                      </td>
                      <td>
                        {location.bucketDistribution?.map((b, i) => (
                          <span key={i} style={{ marginRight: '5px', fontSize: '11px' }}>
                            {b.bucket?.label}: ${b.cashValue?.toFixed(0)}
                          </span>
                        ))}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}

          {activeView === 'categories' && categories.length > 0 && (
            <div>
              <h3>Category Aging Analysis ({categories.length})</h3>
              <table>
                <thead>
                  <tr>
                    <th>Category</th>
                    <th>Cash Tied Up</th>
                    <th>Units</th>
                    <th>Avg Age (days)</th>
                    <th>Buckets</th>
                  </tr>
                </thead>
                <tbody>
                  {categories.map((category) => (
                    <tr key={category.categoryId}>
                      <td><strong>{category.categoryName}</strong></td>
                      <td>${category.totalCashTiedUp?.toFixed(2) || '0.00'}</td>
                      <td>{category.totalUnits || 0}</td>
                      <td>{category.averageAge?.toFixed(1) || '0.0'}</td>
                      <td>
                        {category.bucketDistribution?.map((b, i) => (
                          <span key={i} style={{ marginRight: '5px', fontSize: '11px' }}>
                            {b.bucket?.label}: ${b.cashValue?.toFixed(0)}
                          </span>
                        ))}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}

          {activeView === 'signals' && signals.length > 0 && (
            <div>
              <h3>Actionable Signals ({signals.length})</h3>
              <table>
                <thead>
                  <tr>
                    <th>Type</th>
                    <th>Severity</th>
                    <th>Entity</th>
                    <th>Message</th>
                    <th>Cash at Risk</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody>
                  {signals.map((signal, idx) => (
                    <tr key={idx}>
                      <td>
                        <span className="badge badge-info">
                          {signal.type?.replace(/_/g, ' ')}
                        </span>
                      </td>
                      <td>
                        <span className={`risk-badge ${getRiskClass(signal.severity)}`}>
                          {signal.severity}
                        </span>
                      </td>
                      <td>
                        <strong>{signal.entityName}</strong>
                        <br />
                        <small style={{ color: '#666' }}>{signal.entityType}</small>
                      </td>
                      <td>{signal.message}</td>
                      <td>
                        {signal.cashAtRisk ? `$${signal.cashAtRisk.toFixed(2)}` : '-'}
                      </td>
                      <td>
                        <ul style={{ margin: 0, paddingLeft: '20px', fontSize: '12px' }}>
                          {signal.recommendedActions?.map((action, i) => (
                            <li key={i}>{action}</li>
                          ))}
                        </ul>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}

          {!loading && (
            (activeView === 'summary' && !summary) ||
            (activeView === 'products' && products.length === 0) ||
            (activeView === 'locations' && locations.length === 0) ||
            (activeView === 'categories' && categories.length === 0) ||
            (activeView === 'signals' && signals.length === 0)
          ) && (
            <div style={{ textAlign: 'center', padding: '40px', color: '#666' }}>
              No data available. Make sure you have inventory with quantity &gt; 0.
            </div>
          )}
        </div>
      );
    }

    // InventoryMigration component has been moved to external files
    // See: components/InventoryMigration/index.jsx
    // The component is loaded via script tags above
      const [costBasis, setCostBasis] = useState('DESCRIPTION');
      const [batchSize, setBatchSize] = useState(50);
      
      // Phase 2: Extraction state
      const [extractionSessionId, setExtractionSessionId] = useState(null);
      const [extractionResult, setExtractionResult] = useState(null); // Full result object with metadata
      const [extractionResults, setExtractionResults] = useState([]);
      const [extractionTab, setExtractionTab] = useState('extracting'); // 'extracting', 'approved', 'discarded'
      const [currentExtractingIndex, setCurrentExtractingIndex] = useState(0); // Index of current item being reviewed
      const [editedResults, setEditedResults] = useState({});
      const [costApprovals, setCostApprovals] = useState({}); // Map of productId -> CostApproval data
      const [editingApprovedItem, setEditingApprovedItem] = useState(null); // productId of approved item being edited
      const [editingSkippedItem, setEditingSkippedItem] = useState(null); // productId of skipped item being edited
      const [allSuppliers, setAllSuppliers] = useState([]);
      const [supplierNameMappings, setSupplierNameMappings] = useState([]);
      const [openAutocomplete, setOpenAutocomplete] = useState({});
      const [supplierSuggestions, setSupplierSuggestions] = useState({});
      const [extractionApproved, setExtractionApproved] = useState(false);
      const [manualInputApproved, setManualInputApproved] = useState(false);
      const [currentBatchId, setCurrentBatchId] = useState(null);
      const [batchComplete, setBatchComplete] = useState(false);
      const [supplierInitialsMap, setSupplierInitialsMap] = useState({}); // Track learned initials: { supplierName: [initial1, initial2, ...] }
      
      // Session management state
      const [existingSessions, setExistingSessions] = useState([]);
      const [showSessionSelector, setShowSessionSelector] = useState(false);
      const [selectedSessionToResume, setSelectedSessionToResume] = useState(null);
      
      // Phase 3: Migration state
      const [migrationResult, setMigrationResult] = useState(null);
      const [migrationProgress, setMigrationProgress] = useState(null);
      
      // Phase 4: Report state
      const [reportData, setReportData] = useState(null);
      
      // Common state
      const [locations, setLocations] = useState([]);
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState(null);
      const [currentCutoverId, setCurrentCutoverId] = useState(null);
      
      // Track when dropdown selection is made to prevent onBlur from using wrong value
      const dropdownSelectionRef = useRef({});

      // Close autocomplete when clicking outside
      useEffect(() => {
        const handleClickOutside = (event) => {
          if (!event.target.closest('.autocomplete-container')) {
            setOpenAutocomplete({});
          }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
      }, []);

      useEffect(() => {
        fetchLocations();
        fetchAllSuppliers();
      }, []);

      // Reset current index when extracting items change
      useEffect(() => {
        // Calculate extracting items count from extractionResults
        const extractingCount = extractionResults.filter(r => 
          !r.migrationStatus || r.migrationStatus === 'PENDING'
        ).length;
        
        if (extractingCount > 0) {
          // Ensure index is within bounds
          if (currentExtractingIndex >= extractingCount) {
            setCurrentExtractingIndex(Math.max(0, extractingCount - 1));
          }
        } else {
          setCurrentExtractingIndex(0);
        }
      }, [extractionResults, currentExtractingIndex]);

      const fetchLocations = async () => {
        try {
          const response = await fetch('/locations');
          const data = await response.json();
          if (data.success) {
            setLocations(data.data || []);
          }
        } catch (err) {
          setError(err.message || 'Failed to fetch locations');
        }
      };

      const fetchAllSuppliers = async () => {
        try {
          const response = await fetch('/admin/inventory/cutover/suppliers');
          const data = await response.json();
          if (data.success) {
            const suppliers = data.suppliers || [];
            setAllSuppliers(suppliers);
            return suppliers;
          }
          return [];
        } catch (err) {
          console.error('Failed to fetch suppliers:', err);
          return [];
        }
      };

      const fetchExistingSessions = async (locationId) => {
        try {
          const url = locationId 
            ? `/admin/inventory/cutover/extraction-sessions?locationId=${locationId}`
            : '/admin/inventory/cutover/extraction-sessions';
          const response = await fetch(url);
          const data = await response.json();
          if (data.success) {
            // Filter to only IN_PROGRESS sessions
            const inProgressSessions = data.sessions.filter(s => s.status === 'IN_PROGRESS');
            setExistingSessions(inProgressSessions);
            return inProgressSessions;
          }
          return [];
        } catch (err) {
          console.error('Failed to fetch existing sessions:', err);
          return [];
        }
      };

      // Function to get supplier suggestions based on input
      const getSupplierSuggestions = (inputValue, originalSupplierName) => {
        if (!inputValue || inputValue.trim().length === 0) {
          return [];
        }

        const searchTerm = inputValue.trim().toLowerCase();
        const suggestions = [];

        // 1. First, check if input matches a supplier initial (case-insensitive) - EXACT match
        const initialMatches = allSuppliers
          .filter(s => {
            const initials = Array.isArray(s.initials) ? s.initials : (s.initials ? [s.initials] : []);
            return initials.some(init => init.toLowerCase() === searchTerm.toLowerCase()) && s.isActive;
          })
          .map(s => ({ id: s.id, name: s.name, contactInfo: s.contactInfo, matchType: 'initial', isExactMatch: true }));

        if (initialMatches.length > 0) {
          suggestions.push(...initialMatches);
        }

        // 2. Check if input matches a supplier name exactly (case-insensitive)
        const exactNameMatches = allSuppliers
          .filter(s => s.isActive && s.name.toLowerCase() === searchTerm)
          .map(s => ({ id: s.id, name: s.name, contactInfo: s.contactInfo, matchType: 'name', isExactMatch: true }))
          .filter(s => !suggestions.find(existing => existing.id === s.id)); // Avoid duplicates

        if (exactNameMatches.length > 0) {
          suggestions.push(...exactNameMatches);
        }

        // 3. Check local mappings for renamed suppliers
        const mappingMatches = supplierNameMappings
          .filter(m => 
            m.supplierOriginal.toLowerCase() === searchTerm || 
            m.new.toLowerCase() === searchTerm
          )
          .map(m => {
            // Find the supplier in allSuppliers by the mapped name
            const supplier = allSuppliers.find(s => s.name === m.new);
            if (supplier && supplier.isActive) {
              return { id: supplier.id, name: supplier.name, contactInfo: supplier.contactInfo, matchType: 'mapping', isExactMatch: true };
            }
            // If not found in suppliers, return a virtual suggestion
            return { id: null, name: m.new, contactInfo: null, matchType: 'mapping', isExactMatch: true };
          })
          .filter((s, index, self) => index === self.findIndex(t => t.name === s.name)); // Remove duplicates

        suggestions.push(...mappingMatches);

        // 4. Check supplier names that start with or contain the search term (partial matches)
        if (suggestions.length === 0) {
          const nameMatches = allSuppliers
            .filter(s => {
              if (!s.isActive) return false;
              const nameLower = s.name.toLowerCase();
              return nameLower.startsWith(searchTerm) || nameLower.includes(searchTerm);
            })
            .map(s => ({ id: s.id, name: s.name, contactInfo: s.contactInfo, matchType: 'name', isExactMatch: false }))
            .filter(s => !suggestions.find(existing => existing.name === s.name)); // Avoid duplicates

          suggestions.push(...nameMatches);
        }

        return suggestions.slice(0, 10); // Limit to 10 suggestions
      };

      // Function to auto-select supplier if there's an exact single match
      const autoSelectSupplier = (inputValue, originalSupplierName, productId, entryIdx, isExtractedEntry, currentResult) => {
        if (!inputValue || inputValue.trim().length === 0) {
          return null;
        }

        const suggestions = getSupplierSuggestions(inputValue, originalSupplierName);
        
        // Auto-select if there's exactly one exact match (by initial or exact name)
        const exactMatches = suggestions.filter(s => s.isExactMatch);
        
        if (exactMatches.length === 1) {
          const supplier = exactMatches[0];
          
          // Use functional update to ensure we have the latest state
          setEditedResults(prevResults => {
            const newResults = { ...prevResults };
            
            if (isExtractedEntry) {
              // For extracted entries
              if (!newResults[productId]) {
                newResults[productId] = { ...currentResult };
              }
              if (!newResults[productId].extractedEntries) {
                newResults[productId].extractedEntries = [...currentResult.extractedEntries];
              }
              if (!newResults[productId].extractedEntries[entryIdx]) {
                newResults[productId].extractedEntries[entryIdx] = { ...currentResult.extractedEntries[entryIdx] };
              }
              
              newResults[productId].extractedEntries[entryIdx] = {
                ...newResults[productId].extractedEntries[entryIdx],
                editedSupplierName: supplier.name,
                supplierId: supplier.id,
              };
              
              // Check if this entry is selected
              const isSelected = newResults[productId].extractedEntries[entryIdx].isSelected !== undefined 
                ? newResults[productId].extractedEntries[entryIdx].isSelected 
                : (entryIdx === newResults[productId].extractedEntries.length - 1);
              
              if (isSelected) {
                newResults[productId].selectedSupplierName = supplier.name;
                newResults[productId].selectedSupplierId = supplier.id;
              }
            } else {
              // For manual input
              if (!newResults[productId]) {
                newResults[productId] = { ...currentResult };
              }
              newResults[productId].selectedSupplierName = supplier.name;
              newResults[productId].selectedSupplierId = supplier.id;
            }
            
            return newResults;
          });
          
          // Update supplier name mapping if name changed (for extracted entries only)
          if (isExtractedEntry && originalSupplierName) {
            const isUnknownOrGeneral = !originalSupplierName || originalSupplierName === 'Unknown' || originalSupplierName === 'General';
            if (!isUnknownOrGeneral && supplier.name !== originalSupplierName) {
              setSupplierNameMappings(prev => {
                const filtered = prev.filter(m => m.supplierOriginal !== originalSupplierName);
                return [...filtered, { supplierOriginal: originalSupplierName, new: supplier.name }];
              });
            }
          }
          
          // Close autocomplete
          if (isExtractedEntry) {
            setOpenAutocomplete(prev => {
              const newState = { ...prev };
              delete newState[`${productId}_${entryIdx}`];
              return newState;
            });
          } else {
            setOpenAutocomplete(prev => {
              const newState = { ...prev };
              delete newState[productId];
              return newState;
            });
          }
          
          return supplier.name; // Return the supplier name so we can use it to update the input
        }
        
        return null; // No auto-selection
      };

      // Handler: Resume an existing session
      const handleResumeSession = async (sessionId) => {
        setExtractionSessionId(sessionId);
        setShowSessionSelector(false);
        setSelectedSessionToResume(sessionId);
        setLoading(true);
        setError(null);
        
        // Load the session to get current batch info
        try {
          const sessionResponse = await fetch(`/admin/inventory/cutover/extraction-session/${sessionId}`);
          const sessionData = await sessionResponse.json();
          if (sessionData.success) {
            // Set location and other config from session
            if (sessionData.session.locationIds && sessionData.session.locationIds.length > 0) {
              setSelectedLocationId(sessionData.session.locationIds[0]);
            }
            // Set batch size from session, but preserve user input if they changed it
            // Only update if the current value is still the default (50) or matches the session
            if (sessionData.session.batchSize) {
              // If user hasn't changed from default, use session value
              // Otherwise, keep user's input (they may have changed it in the UI)
              if (batchSize === 50 || batchSize === sessionData.session.batchSize) {
                setBatchSize(sessionData.session.batchSize);
              }
              // If batchSize is different from session and not default, keep user's value
            }
            
            // Load learned supplier initials
            if (sessionData.session.learnedSupplierInitials) {
              setSupplierInitialsMap(sessionData.session.learnedSupplierInitials);
            }
            
            // Get the latest batch to check if we should load it or continue to next
            const batches = sessionData.session.batches || [];
            const latestBatch = batches.length > 0 ? batches[batches.length - 1] : null;
            
            // If latest batch exists and is not fully approved, load current batch items
            // Otherwise, continue to next batch
            if (latestBatch && latestBatch.status === 'EXTRACTED') {
              // Load current batch - call extract-costs which will return current batch items
              // The backend should return the current batch's items when sessionId is provided
              await handleExtractCosts(true);
          } else {
              // No current batch or batch is approved, continue to next batch
              await handleExtractCosts(true);
            }
          } else {
            setError('Failed to load session: ' + (sessionData.message || 'Unknown error'));
            setLoading(false);
          }
        } catch (err) {
          setError('Failed to resume session: ' + err.message);
          setLoading(false);
        }
      };

      // Handler: Continue extraction (legacy function for compatibility)
      const handleExtractCosts = async (continueExtraction = false) => {
        if (!continueExtraction && !selectedLocationId) {
          setError('Please select a location');
          return;
        }

        setLoading(true);
        setError(null);
        if (!continueExtraction) {
          setExtractionResults([]);
          setExtractionSessionId(null);
        }

        try {
          const response = await fetch('/admin/inventory/cutover/extract-costs', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              locationIds: selectedLocationId ? [selectedLocationId] : [],
              costBasis: costBasis,
              batchSize: continueExtraction ? null : batchSize,
              newBatchSize: continueExtraction ? (batchSize && batchSize > 0 ? batchSize : null) : null,
              extractionSessionId: continueExtraction ? extractionSessionId : null,
            }),
          });

          const data = await response.json();
          if (response.ok && data.success) {
            const result = data.result;
            
            // Match supplier initials to full supplier names and apply supplier name mappings
            if (result.extractionResults) {
              result.extractionResults = result.extractionResults.map(productResult => {
                if (productResult.extractedEntries) {
                  // First pass: find all matches
                  const entriesWithMatches = productResult.extractedEntries.map((entry, idx) => {
                    const originalSupplier = entry.supplier;
                    let matchedSupplierName = null;
                    let matchedSupplierId = null;
                    
                    // DO NOT apply matching for Unknown/General/null suppliers
                    const isUnknownOrGeneral = !originalSupplier || originalSupplier === 'Unknown' || originalSupplier === 'General';
                    
                    if (!isUnknownOrGeneral && originalSupplier) {
                      // First, try to match by supplier initial (case-insensitive)
                      const supplierInitial = originalSupplier.trim().toLowerCase();
                      const matchedByInitial = allSuppliers.find(s => 
                        (() => {
                          const initials = Array.isArray(s.initials) ? s.initials : (s.initials ? [s.initials] : []);
                          return initials.some(init => init.toLowerCase() === supplierInitial.toLowerCase()) && s.isActive;
                        })()
                      );
                      
                      if (matchedByInitial) {
                        matchedSupplierName = matchedByInitial.name;
                        matchedSupplierId = matchedByInitial.id;
                      } else {
                        // Second, try to match by supplier name (case-insensitive exact match)
                        const matchedByName = allSuppliers.find(s => 
                          s.name.toLowerCase() === originalSupplier.toLowerCase() && s.isActive
                        );
                        
                        if (matchedByName) {
                          matchedSupplierName = matchedByName.name;
                          matchedSupplierId = matchedByName.id;
                        }
                      }
                      
                      // Third, check supplier name mappings if no direct match found
                      if (!matchedSupplierName && supplierNameMappings.length > 0) {
                        const mapping = supplierNameMappings.find(m => m.supplierOriginal === originalSupplier);
                        if (mapping) {
                          matchedSupplierName = mapping.new;
                          // Try to find supplier ID for the mapped name
                          const mappedSupplier = allSuppliers.find(s => 
                            s.name === mapping.new && s.isActive
                          );
                          if (mappedSupplier) {
                            matchedSupplierId = mappedSupplier.id;
                          }
                        }
                      }
                    }
                    
                    return {
                      entry,
                      idx,
                      matchedSupplierName,
                      matchedSupplierId,
                    };
                  });
                  
                  // Preserve the backend's selection (last entry is selected by default)
                  // Supplier matching should NOT change which entry is selected
                  
                  // Map entries with selection logic
                  productResult.extractedEntries = productResult.extractedEntries.map((entry, idx) => {
                    const matchInfo = entriesWithMatches[idx];
                    
                    if (matchInfo.matchedSupplierName) {
                      return {
                        ...entry,
                        supplier: matchInfo.entry.supplier, // Keep original extracted value for display (e.g., "L")
                        editedSupplierName: matchInfo.matchedSupplierName, // Use matched full name for input (e.g., "Levic")
                        supplierId: matchInfo.matchedSupplierId,
                        // Preserve the backend's isSelected flag (last entry is selected by default)
                        isSelected: entry.isSelected !== undefined ? entry.isSelected : (idx === productResult.extractedEntries.length - 1),
                      };
                    }
                    
                    return {
                      ...entry,
                      // Preserve the backend's isSelected flag (last entry is selected by default)
                      isSelected: entry.isSelected !== undefined ? entry.isSelected : (idx === productResult.extractedEntries.length - 1),
                    };
                  });
                  
                  // Update selectedSupplierName to the selected entry (the one with isSelected: true), or last entry as fallback
                  const selectedEntry = productResult.extractedEntries.find(e => e.isSelected) 
                    || productResult.extractedEntries[productResult.extractedEntries.length - 1];
                  
                  if (selectedEntry) {
                    productResult.selectedSupplierName = selectedEntry.editedSupplierName || selectedEntry.supplier;
                    productResult.selectedSupplierId = selectedEntry.supplierId;
                    productResult.selectedCost = selectedEntry.editedCost !== null && selectedEntry.editedCost !== undefined 
                      ? selectedEntry.editedCost 
                      : selectedEntry.amount;
                  }
                }
                return productResult;
              });
            }
            
            // Clear previous batch items from editedResults, keep only current batch
            if (continueExtraction && result.extractionResults) {
              const currentBatchProductIds = new Set(result.extractionResults.map(r => r.productId));
              setEditedResults(prev => {
                const filtered = {};
                // Only keep items from current batch
                currentBatchProductIds.forEach(productId => {
                  if (prev[productId]) {
                    filtered[productId] = prev[productId];
                  }
                });
                return filtered;
              });
            } else if (!continueExtraction) {
              // New extraction session - clear all edited results
              setEditedResults({});
            }
            
            setExtractionResult(result);
            if (result.extractionSessionId) {
              setExtractionSessionId(result.extractionSessionId);
              
              // Fetch session to get current batch ID
              try {
                const sessionResponse = await fetch(`/admin/inventory/cutover/extraction-session/${result.extractionSessionId}`);
                const sessionData = await sessionResponse.json();
                if (sessionData.success && sessionData.session.batches && sessionData.session.batches.length > 0) {
                  // Get the latest batch (current batch)
                  const latestBatch = sessionData.session.batches[sessionData.session.batches.length - 1];
                  setCurrentBatchId(latestBatch.id);
                  
                  // Load learned supplier initials
                  if (sessionData.session.learnedSupplierInitials) {
                    setSupplierInitialsMap(sessionData.session.learnedSupplierInitials);
                  }
                }
              } catch (err) {
                console.warn('Failed to fetch session details:', err);
              }
            }
            // Reset approval checkboxes for new batch
            setExtractionApproved(false);
            setManualInputApproved(false);
            
            // Set extraction results and transition to extracting state
            setExtractionResults(result.extractionResults || []);
            setState('extracting');
            
            // Allow moving to approve step even if incomplete
            // User can choose to review partial results or continue extraction
          } else {
            setError(data.message || 'Failed to extract costs');
          }
        } catch (err) {
          setError(err.message || 'Failed to extract costs');
        } finally {
          setLoading(false);
        }
      };

      const handleApproveBatch = async () => {
        if (!extractionResult || !currentBatchId || !extractionSessionId) {
          setError('Missing batch or session information');
          return;
        }

        // Validate both checkboxes are checked
        if (!extractionApproved || !manualInputApproved) {
          setError('Both extraction and manual input items must be approved to continue');
          return;
        }

        setLoading(true);
        setError(null);

        try {
          // Use edited results if available, otherwise use original
          const resultsToUse = Object.keys(editedResults).length > 0
            ? extractionResult.extractionResults.map(r => editedResults[r.productId] || r)
            : extractionResult.extractionResults;

          const approvedCostsArray = resultsToUse
            .filter(r => {
              // Include already-approved products (they pass through)
              if (r.isAlreadyApproved) {
                return true;
              }
              const cost = r.selectedCost || (r.extractedEntries.length > 0 ? r.extractedEntries[r.extractedEntries.length - 1]?.amount : null);
              return cost !== null && cost !== undefined;
            })
            .map(r => {
              // Handle already-approved products
              if (r.isAlreadyApproved) {
                const approvedCost = r.existingApprovedCost 
                  ? (typeof r.existingApprovedCost === 'object' && r.existingApprovedCost.toNumber 
                      ? r.existingApprovedCost.toNumber() 
                      : r.existingApprovedCost)
                  : r.selectedCost || 0;
                return {
                  productId: r.productId,
                  cost: approvedCost,
                  source: 'ALREADY_APPROVED',
                  supplierId: null,
                  supplierName: 'General',
                  isPreferred: false,
                };
              }
              
              const edited = editedResults[r.productId] || r;
              const selectedEntry = edited.extractedEntries.find(e => e.isSelected) 
                || (edited.extractedEntries.length > 0 ? edited.extractedEntries[edited.extractedEntries.length - 1] : null);
              const cost = edited.selectedCost !== null && edited.selectedCost !== undefined 
                ? edited.selectedCost 
                : (selectedEntry ? (selectedEntry.editedCost !== null && selectedEntry.editedCost !== undefined ? selectedEntry.editedCost : selectedEntry.amount) : null);
              const supplierId = edited.selectedSupplierId || selectedEntry?.supplierId || null;
              const supplierName = edited.selectedSupplierName || (selectedEntry ? (selectedEntry.editedSupplierName || selectedEntry.supplier) : null) || 'General';
              const preferredSupplierName = edited.preferredSupplierName !== undefined ? edited.preferredSupplierName : supplierName;
              const isPreferred = preferredSupplierName === supplierName;

              return {
                productId: r.productId,
                cost: cost,
                source: edited.extractedEntries.length > 0 ? 'EXTRACTED_SELECTED' : 'MANUAL_INPUT',
                supplierId: supplierId,
                supplierName: supplierName,
                isPreferred: isPreferred,
              };
            });

          // Collect entries to add to supplier history
          const entriesToAddToHistory = [];
          resultsToUse.forEach(r => {
            const edited = editedResults[r.productId] || r;
            edited.extractedEntries.forEach((entry, idx) => {
              const shouldAdd = entry.addToHistory !== undefined 
                ? entry.addToHistory 
                : (idx === edited.extractedEntries.length - 1);
              
              if (shouldAdd && entry.amount) {
                const supplierName = entry.editedSupplierName || entry.supplier;
                if (supplierName && supplierName.trim() && supplierName !== 'General') {
                  entriesToAddToHistory.push({
                    productId: r.productId,
                    supplierName: supplierName.trim(),
                    supplierId: entry.supplierId || null,
                    cost: entry.amount,
                    effectiveAt: null,
                  });
                }
              }
            });
          });

          // Collect supplier initials updates
          const supplierInitialsUpdates = Object.entries(supplierInitialsMap).map(([supplierName, initials]) => ({
            supplierName,
            initials: Array.isArray(initials) ? initials : [initials],
          }));

          const response = await fetch('/admin/inventory/cutover/approve-batch', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              extractionSessionId: extractionSessionId,
              batchId: currentBatchId,
              extractionApproved: extractionApproved,
              manualInputApproved: manualInputApproved,
              approvedCosts: approvedCostsArray,
              entriesToAddToHistory: entriesToAddToHistory.length > 0 ? entriesToAddToHistory : null,
              supplierInitialsUpdates: supplierInitialsUpdates.length > 0 ? supplierInitialsUpdates : null,
            }),
          });

          const data = await response.json();
          if (response.ok && data.success) {
            setApprovedCosts(approvedCostsArray.reduce((acc, ac) => {
              acc[ac.productId] = ac.cost;
              return acc;
            }, {}));
            
            // If next batch is available, extract it; otherwise proceed to migration
            if (data.nextBatchAvailable) {
              // Continue extraction for next batch
              await handleExtractCosts(true);
              setStep('approve');
            } else {
              // All batches approved, proceed to migration
              setStep('migrate');
            }
          } else {
            setError(data.message || 'Failed to approve batch');
          }
        } catch (err) {
          setError(err.message || 'Failed to approve batch');
        } finally {
          setLoading(false);
        }
      };

      const handleApproveCosts = async () => {
        // Legacy function - redirect to batch approval if batch ID is available
        if (currentBatchId && extractionSessionId) {
          return handleApproveBatch();
        }
        
        // Fallback to old approval flow if no batch
        if (!extractionResult) return;

        setLoading(true);
        setError(null);

        try {
          // Use edited results if available, otherwise use original
          const resultsToUse = Object.keys(editedResults).length > 0
            ? extractionResult.extractionResults.map(r => editedResults[r.productId] || r)
            : extractionResult.extractionResults;

          const approvedCostsArray = resultsToUse
            .filter(r => {
              // Include already-approved products (they pass through)
              if (r.isAlreadyApproved) {
                return true;
              }
              const cost = r.selectedCost || (r.extractedEntries.length > 0 ? r.extractedEntries[r.extractedEntries.length - 1]?.amount : null);
              return cost !== null && cost !== undefined;
            })
            .map(r => {
              // Handle already-approved products
              if (r.isAlreadyApproved) {
                const approvedCost = r.existingApprovedCost 
                  ? (typeof r.existingApprovedCost === 'object' && r.existingApprovedCost.toNumber 
                      ? r.existingApprovedCost.toNumber() 
                      : r.existingApprovedCost)
                  : r.selectedCost || 0;
                return {
                  productId: r.productId,
                  cost: approvedCost,
                  source: 'ALREADY_APPROVED', // Indicate this was already approved
                  supplierId: null,
                  supplierName: 'General',
                  isPreferred: false,
                };
              }
              
              const edited = editedResults[r.productId] || r;
              // Find the selected entry (marked with isSelected: true)
              const selectedEntry = edited.extractedEntries.find(e => e.isSelected) 
                || (edited.extractedEntries.length > 0 ? edited.extractedEntries[edited.extractedEntries.length - 1] : null);
              const cost = edited.selectedCost !== null && edited.selectedCost !== undefined 
                ? edited.selectedCost 
                : (selectedEntry ? (selectedEntry.editedCost !== null && selectedEntry.editedCost !== undefined ? selectedEntry.editedCost : selectedEntry.amount) : null);
              const supplierId = edited.selectedSupplierId || selectedEntry?.supplierId || null;
              const supplierName = edited.selectedSupplierName || (selectedEntry ? (selectedEntry.editedSupplierName || selectedEntry.supplier) : null) || 'General';
              // Check if preferred supplier (from dropdown) matches selected supplier
              const preferredSupplierName = edited.preferredSupplierName !== undefined ? edited.preferredSupplierName : supplierName;
              const isPreferred = preferredSupplierName === supplierName;

              return {
                productId: r.productId,
                cost: cost,
                source: edited.extractedEntries.length > 0 ? 'EXTRACTED_SELECTED' : 'MANUAL_INPUT',
                supplierId: supplierId,
                supplierName: supplierName,
                isPreferred: isPreferred,
              };
            });

          // Collect all entries marked to add to supplier history
          const entriesToAddToHistory = [];
          resultsToUse.forEach(r => {
            const edited = editedResults[r.productId] || r;
            edited.extractedEntries.forEach((entry, idx) => {
              // Check if this entry should be added to history
              const shouldAdd = entry.addToHistory !== undefined 
                ? entry.addToHistory 
                : (idx === edited.extractedEntries.length - 1); // Default: only selected entry
              
              if (shouldAdd && entry.amount) {
                const supplierName = entry.editedSupplierName || entry.supplier;
                if (supplierName && supplierName.trim() && supplierName !== 'General') {
                  entriesToAddToHistory.push({
                    productId: r.productId,
                    supplierName: supplierName.trim(),
                    supplierId: entry.supplierId || null,
                    cost: entry.amount,
                    effectiveAt: null, // Will use cutover date
                  });
                }
              }
            });
          });

          const response = await fetch('/admin/inventory/cutover/approve-costs', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              cutoverId: extractionResult.cutoverId,
              approvedCosts: approvedCostsArray,
              entriesToAddToHistory: entriesToAddToHistory.length > 0 ? entriesToAddToHistory : null,
              rejectedProducts: [],
              effectiveAt: cutoverDate + 'T00:00:00Z',
            }),
          });

          const data = await response.json();
          if (response.ok && data.success) {
            setApprovedCosts(approvedCostsArray.reduce((acc, ac) => {
              acc[ac.productId] = ac.cost;
              return acc;
            }, {}));
            setStep('migrate');
          } else {
            setError(data.message || 'Failed to approve costs');
          }
        } catch (err) {
          setError(err.message || 'Failed to approve costs');
        } finally {
          setLoading(false);
        }
      };

      const handlePreview = async () => {
        if (!selectedLocation) {
          setError('Please select a location');
          return;
        }

        setLoading(true);
        setError(null);
        setPreviewResult(null);

        try {
          const response = await fetch('/admin/inventory/cutover/preview', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              cutoverDate: cutoverDate + 'T00:00:00Z',
              locationIds: selectedLocation ? [selectedLocation] : [],
              costBasis: costBasis,
              approvedCosts: Object.keys(approvedCosts).map(productId => ({
                productId,
                cost: approvedCosts[productId],
              })),
            }),
          });

          const data = await response.json();
          if (response.ok) {
            setPreviewResult(data);
          } else {
            setError(data.message || 'Failed to preview migration');
          }
        } catch (err) {
          setError(err.message || 'Failed to preview migration');
        } finally {
          setLoading(false);
        }
      };

      const handleMigrate = async (continueMigration = false) => {
        if (!continueMigration && !selectedLocation) {
          setError('Please select a location');
          return;
        }

        if (!continueMigration && !window.confirm('Are you sure you want to execute the inventory migration? This will create opening balances and lock the system.')) {
          return;
        }

        setLoading(true);
        setError(null);
        if (!continueMigration) {
          setMigrationResult(null);
        }

        try {
          let response;
          if (continueMigration && currentCutoverId) {
            // Continue batch migration
            response = await fetch('/admin/inventory/cutover/continue', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                cutoverId: currentCutoverId,
              }),
            });
          } else {
            // Start new migration
            response = await fetch('/admin/inventory/cutover', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                cutoverDate: cutoverDate + 'T00:00:00Z',
                locationIds: selectedLocation ? [selectedLocation] : [],
                costBasis: costBasis,
                ownerApproved: true,
                approvalId: extractionResult?.cutoverId,
                manualCosts: Object.keys(approvedCosts).map(productId => ({
                  productId,
                  cost: approvedCosts[productId],
                })),
                batchSize: batchSize && batchSize > 0 ? batchSize : null,
              }),
            });
          }

          const data = await response.json();
          if (response.ok && data.success) {
            setMigrationResult(data.result);
            if (data.result.cutoverId) {
              setCurrentCutoverId(data.result.cutoverId);
            }
            if (data.result.isComplete) {
              setStep('complete');
            } else {
              setStep('migrate'); // Stay on migrate step to show continue button
            }
          } else {
            setError(data.message || 'Migration failed');
          }
        } catch (err) {
          setError(err.message || 'Migration failed');
        } finally {
          setLoading(false);
        }
      };

      // Handler: Start extraction session (Phase 1 -> Phase 2)
      const handleStartExtraction = async () => {
        if (!selectedLocationId) {
          setError('Please select a location');
          return;
        }
        if (new Date(cutoverDate) > new Date()) {
          setError('Cutover date cannot be in the future');
          return;
        }
        if (batchSize < 10 || batchSize > 500) {
          setError('Batch size must be between 10 and 500');
          return;
        }

        // Check for existing sessions
        const sessions = await fetchExistingSessions(selectedLocationId);
        if (sessions.length > 0) {
          setShowSessionSelector(true);
          return;
        }

        // No existing sessions, proceed with new extraction
        await handleExtractCosts(false);
      };

      // Handler: Start new extraction (called from session selector or directly)
      const handleStartNewExtraction = async () => {
        setLoading(true);
        setError(null);
        try {
          const response = await fetch('/admin/inventory/cutover/extract-costs', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              locationIds: [selectedLocationId],
              costBasis: costBasis,
              batchSize: batchSize,
            }),
          });

          const data = await response.json();
          if (data.success) {
            const result = data.result;
            
            // Match supplier initials to full supplier names
            if (result.extractionResults) {
              result.extractionResults = result.extractionResults.map(productResult => {
                if (productResult.extractedEntries) {
                  productResult.extractedEntries = productResult.extractedEntries.map((entry, idx) => {
                    const originalSupplier = entry.supplier;
                    let matchedSupplierName = null;
                    let matchedSupplierId = null;
                    let matchedByInitial = false; // Declare outside if block
                    
                    const isUnknownOrGeneral = !originalSupplier || originalSupplier === 'Unknown' || originalSupplier === 'General';
                    
                    if (!isUnknownOrGeneral && originalSupplier) {
                      const supplierInitial = originalSupplier.trim().toLowerCase();
                      const matchedByInitialResult = allSuppliers.find(s => {
                        const initials = Array.isArray(s.initials) ? s.initials : (s.initials ? [s.initials] : []);
                        return initials.some(init => init.toLowerCase() === supplierInitial) && s.isActive;
                      });
                      
                      if (matchedByInitialResult) {
                        matchedSupplierName = matchedByInitialResult.name;
                        matchedSupplierId = matchedByInitialResult.id;
                        matchedByInitial = true;
                      } else {
                        const matchedByName = allSuppliers.find(s => 
                          s.name.toLowerCase() === originalSupplier.toLowerCase() && s.isActive
                        );
                        if (matchedByName) {
                          matchedSupplierName = matchedByName.name;
                          matchedSupplierId = matchedByName.id;
                        }
                      }
                    }
                    
                    return {
                      ...entry,
                      supplier: originalSupplier,
                      editedSupplierName: matchedSupplierName || originalSupplier,
                      supplierId: matchedSupplierId,
                      isSelected: idx === productResult.extractedEntries.length - 1,
                      matchedByInitial: matchedByInitial, // Track if matched by initial
                    };
                  });
                  
                  const lastEntry = productResult.extractedEntries[productResult.extractedEntries.length - 1];
                  if (lastEntry) {
                    productResult.selectedCost = lastEntry.editedCost !== null && lastEntry.editedCost !== undefined 
                      ? lastEntry.editedCost 
                      : lastEntry.amount;
                    productResult.selectedSupplierName = lastEntry.editedSupplierName || lastEntry.supplier;
                    productResult.selectedSupplierId = lastEntry.supplierId;
                  }
                }
                return productResult;
              });
            }
            
            setExtractionSessionId(result.extractionSessionId);
            setExtractionResults(result.extractionResults || []);
            setCurrentCutoverId(result.cutoverId);
            setEditedResults({});
            setState('extracting');
            
            // Fetch session to get current batch ID
            if (result.extractionSessionId) {
              try {
                const sessionResponse = await fetch(`/admin/inventory/cutover/extraction-session/${result.extractionSessionId}`);
                const sessionData = await sessionResponse.json();
                if (sessionData.success && sessionData.session.batches && sessionData.session.batches.length > 0) {
                  const latestBatch = sessionData.session.batches[sessionData.session.batches.length - 1];
                  setCurrentBatchId(latestBatch.id);
                  
                  // Load learned supplier initials
                  if (sessionData.session.learnedSupplierInitials) {
                    setSupplierInitialsMap(sessionData.session.learnedSupplierInitials);
                  }
                }
              } catch (err) {
                console.warn('Failed to fetch session details:', err);
              }
            }
          } else {
            setError(data.message || 'Failed to start extraction');
          }
        } catch (err) {
          setError(err.message || 'Failed to start extraction');
        } finally {
          setLoading(false);
        }
      };

      // Handler: Discard item
      const handleDiscardItem = async (productId) => {
        // Use currentCutoverId or fallback to extractionResult.cutoverId or extractionSessionId
        const cutoverId = currentCutoverId || extractionResult?.cutoverId || extractionSessionId;
        if (!cutoverId) {
          setError('Missing cutover ID. Please start extraction first.');
          return;
        }
        try {
          const response = await fetch('/admin/inventory/cutover/discard-item', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ cutoverId, productId }),
          });
          const data = await response.json();
          if (response.ok && data.success) {
            setExtractionResults(prev => prev.map(r => 
              r.productId === productId ? { ...r, migrationStatus: 'SKIPPED' } : r
            ));
            
            // Move to next item if available, otherwise stay at current (which will become last after removal)
            setCurrentExtractingIndex(prev => {
              const currentExtractingCount = extractionResults.filter(r => 
                !r.migrationStatus || r.migrationStatus === 'PENDING'
              ).length;
              // After discard, one item will be removed, so if we're not at the last item, move forward
              // If we're at the last item, stay at current index (it will become the new last item)
              if (prev < currentExtractingCount - 1) {
                return prev; // Stay at same index (next item will move into this position)
              } else {
                // We're at the last item, move to previous if available
                return Math.max(0, prev - 1);
              }
            });
          } else {
            setError(data.message || 'Failed to discard item');
          }
        } catch (err) {
          setError(err.message || 'Failed to discard item');
        }
      };

      // Handler: Restore item
      const handleRestoreItem = async (productId) => {
        // Use currentCutoverId or fallback to extractionResult.cutoverId or extractionSessionId
        const cutoverId = currentCutoverId || extractionResult?.cutoverId || extractionSessionId;
        if (!cutoverId) {
          setError('Missing cutover ID. Please start extraction first.');
          return;
        }
        try {
          const response = await fetch('/admin/inventory/cutover/restore-item', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ cutoverId, productId }),
          });
          const data = await response.json();
          if (response.ok && data.success) {
            setExtractionResults(prev => prev.map(r => 
              r.productId === productId ? { ...r, migrationStatus: 'PENDING' } : r
            ));
          } else {
            setError(data.message || 'Failed to restore item');
          }
        } catch (err) {
          setError(err.message || 'Failed to restore item');
        }
      };

      // Handler: Continue to next batch
      const handleContinueBatch = async () => {
        console.log('handleContinueBatch called', { extractionSessionId, selectedLocationId, batchSize });
        
        if (!extractionSessionId) {
          setError('Missing session ID. Please resume the session first.');
          setBatchComplete(false);
          return;
        }
        
        setLoading(true);
        setError(null);
        setBatchComplete(false); // Close modal immediately
        
        try {
          const requestBody = {
            locationIds: [selectedLocationId],
            costBasis: costBasis,
            batchSize: null,
            newBatchSize: batchSize && batchSize > 0 ? batchSize : null,
            extractionSessionId: extractionSessionId,
          };
          console.log('Continuing batch with:', requestBody);
          
          const response = await fetch('/admin/inventory/cutover/extract-costs', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              locationIds: [selectedLocationId],
              costBasis: costBasis,
              batchSize: null,
              newBatchSize: batchSize && batchSize > 0 ? batchSize : null,
              extractionSessionId: extractionSessionId,
            }),
          });
          
          if (!response.ok) {
            const errorData = await response.json().catch(() => ({ message: 'Failed to continue batch' }));
            throw new Error(errorData.message || `HTTP ${response.status}: Failed to continue batch`);
          }
          
          const data = await response.json();
          console.log('Continue batch response:', { success: data.success, resultCount: data.result?.extractionResults?.length, isComplete: data.result?.isComplete });
          
          if (data.success) {
            const result = data.result;
            
            // Match supplier initials (same logic as handleStartExtraction)
            if (result.extractionResults) {
              result.extractionResults = result.extractionResults.map(productResult => {
                if (productResult.extractedEntries) {
                  productResult.extractedEntries = productResult.extractedEntries.map((entry, idx) => {
                    const originalSupplier = entry.supplier;
                    let matchedSupplierName = null;
                    let matchedSupplierId = null;
                    let matchedByInitial = false; // Declare outside if block
                    
                    const isUnknownOrGeneral = !originalSupplier || originalSupplier === 'Unknown' || originalSupplier === 'General';
                    
                    if (!isUnknownOrGeneral && originalSupplier) {
                      const supplierInitial = originalSupplier.trim().toLowerCase();
                      const matchedByInitialResult = allSuppliers.find(s => {
                        const initials = Array.isArray(s.initials) ? s.initials : (s.initials ? [s.initials] : []);
                        return initials.some(init => init.toLowerCase() === supplierInitial) && s.isActive;
                      });
                      
                      if (matchedByInitialResult) {
                        matchedSupplierName = matchedByInitialResult.name;
                        matchedSupplierId = matchedByInitialResult.id;
                        matchedByInitial = true;
                      } else {
                        const matchedByName = allSuppliers.find(s => 
                          s.name.toLowerCase() === originalSupplier.toLowerCase() && s.isActive
                        );
                        if (matchedByName) {
                          matchedSupplierName = matchedByName.name;
                          matchedSupplierId = matchedByName.id;
                        }
                      }
                    }
                    
                    return {
                      ...entry,
                      supplier: originalSupplier,
                      editedSupplierName: matchedSupplierName || originalSupplier,
                      supplierId: matchedSupplierId,
                      isSelected: matchedSupplierName ? true : (idx === productResult.extractedEntries.length - 1), // Auto-select if matched
                      matchedByInitial: matchedByInitial, // Track if matched by initial
                    };
                  });
                  
                  // Update selectedSupplierName to the first matched entry, or last entry as fallback
                  const matchedEntry = productResult.extractedEntries.find(e => e.isSelected && e.editedSupplierName && e.supplierId) ||
                    productResult.extractedEntries[productResult.extractedEntries.length - 1];
                  if (matchedEntry) {
                    productResult.selectedCost = matchedEntry.editedCost !== null && matchedEntry.editedCost !== undefined 
                      ? matchedEntry.editedCost 
                      : matchedEntry.amount;
                    productResult.selectedSupplierName = matchedEntry.editedSupplierName || matchedEntry.supplier;
                    productResult.selectedSupplierId = matchedEntry.supplierId;
                  }
                }
                return productResult;
              });
            }
            
            // Clear edited results for items not in new batch
            const newBatchProductIds = new Set((result.extractionResults || []).map(r => r.productId));
            setEditedResults(prev => {
              const filtered = {};
              newBatchProductIds.forEach(productId => {
                if (prev[productId]) {
                  filtered[productId] = prev[productId];
                }
              });
              return filtered;
            });
            
            // Set full extraction result
            setExtractionResult(result);
            if (result.extractionSessionId) {
              setExtractionSessionId(result.extractionSessionId);
              
              // Fetch session to get current batch ID
              try {
                const sessionResponse = await fetch(`/admin/inventory/cutover/extraction-session/${result.extractionSessionId}`);
                const sessionData = await sessionResponse.json();
                if (sessionData.success && sessionData.session.batches && sessionData.session.batches.length > 0) {
                  // Get the latest batch (current batch)
                  const latestBatch = sessionData.session.batches[sessionData.session.batches.length - 1];
                  setCurrentBatchId(latestBatch.id);
                  
                  // Load learned supplier initials
                  if (sessionData.session.learnedSupplierInitials) {
                    setSupplierInitialsMap(sessionData.session.learnedSupplierInitials);
                  }
                }
              } catch (err) {
                console.warn('Failed to fetch session details:', err);
              }
            }
            
            // Reset approval checkboxes for new batch
            setExtractionApproved(false);
            setManualInputApproved(false);
            
            // Set extraction results and transition to extracting state
            let newResults = result.extractionResults || [];
            
            // Check migration status of new results BEFORE fixing
            const statusCountsBefore = {
              PENDING: 0,
              APPROVED: 0,
              SKIPPED: 0,
              undefined: 0
            };
            newResults.forEach(r => {
              const status = r.migrationStatus || 'undefined';
              statusCountsBefore[status] = (statusCountsBefore[status] || 0) + 1;
            });
            
            // CRITICAL FIX: New batch items should have PENDING status
            // Reset migrationStatus to PENDING for items that aren't already approved
            newResults = newResults.map(r => {
              // If it's a new item (not already approved), ensure it's PENDING
              if (!r.isAlreadyApproved) {
                if (r.migrationStatus && r.migrationStatus !== 'PENDING') {
                  console.warn('Resetting migrationStatus to PENDING for new batch item:', r.productId, 'was:', r.migrationStatus);
                  return { ...r, migrationStatus: 'PENDING' };
                }
                // If no migrationStatus, set it to PENDING
                if (!r.migrationStatus) {
                  return { ...r, migrationStatus: 'PENDING' };
                }
              }
              return r;
            });
            
            // Check migration status AFTER fixing
            const statusCountsAfter = {
              PENDING: 0,
              APPROVED: 0,
              SKIPPED: 0,
              undefined: 0
            };
            newResults.forEach(r => {
              const status = r.migrationStatus || 'undefined';
              statusCountsAfter[status] = (statusCountsAfter[status] || 0) + 1;
            });
            
            console.log('Setting new extraction results:', { 
              count: newResults.length, 
              isComplete: result.isComplete,
              currentState: state,
              currentBatchComplete: batchComplete,
              statusCountsBefore: statusCountsBefore,
              statusCountsAfter: statusCountsAfter,
              pendingCount: newResults.filter(r => (r.migrationStatus === 'PENDING' || !r.migrationStatus) && !r.isAlreadyApproved).length
            });
            
            // Close modal and update state immediately
            setBatchComplete(false);
            setExtractionResults(newResults);
            
            // Check if we have results or if extraction is complete
            if (result.isComplete || newResults.length === 0) {
              // No more items to extract, go to review
              console.log('Extraction complete, transitioning to reviewing');
              setState('reviewing');
            } else {
              // We have new items, stay in extracting state
              console.log('New batch loaded, transitioning to extracting state');
              setState('extracting');
            }
            
            console.log('State updates completed');
          } else {
            const errorMsg = data.message || 'Failed to continue batch';
            setError(errorMsg);
            console.error('Continue batch failed:', errorMsg, data);
            setBatchComplete(false);
          }
        } catch (err) {
          const errorMsg = err.message || 'Failed to continue batch';
          setError(errorMsg);
          console.error('Continue batch error:', err);
          setBatchComplete(false);
        } finally {
          setLoading(false);
        }
      };

      // Handler: Approve item with edited results
      const handleApproveItem = async (result) => {
        // Use currentCutoverId or fallback to extractionResult.cutoverId or extractionSessionId
        const cutoverId = currentCutoverId || extractionResult?.cutoverId || extractionSessionId;
        if (!cutoverId) {
          setError('Missing cutover ID. Please start extraction first.');
          return;
        }

        const edited = editedResults[result.productId] || result;
        const hasExtraction = edited.extractedEntries && edited.extractedEntries.length > 0;
        const selectedEntry = edited.extractedEntries?.find(e => e.isSelected) || 
          (edited.extractedEntries?.length > 0 ? edited.extractedEntries[edited.extractedEntries.length - 1] : null);
        
        const cost = edited.selectedCost !== null && edited.selectedCost !== undefined 
          ? edited.selectedCost 
          : (selectedEntry ? (selectedEntry.editedCost !== null && selectedEntry.editedCost !== undefined ? selectedEntry.editedCost : selectedEntry.amount) : null);
        
        if (cost === null || cost === undefined || cost <= 0) {
          setError('Please enter a valid cost');
          return;
        }
        
        if (!hasExtraction && !edited.selectedSupplierName) {
          setError('Please enter a supplier name');
          return;
        }
        
        const supplierName = edited.selectedSupplierName || (selectedEntry ? (selectedEntry.editedSupplierName || selectedEntry.supplier) : null) || 'General';
        const supplierId = edited.selectedSupplierId || selectedEntry?.supplierId || null;
        
        // Collect all initials that need to be added from all extracted entries
        // Compare original entries with edited entries to find corrections
        const initialsToAdd = [];
        if (hasExtraction && edited.extractedEntries && result.extractedEntries) {
          // Get original entries for comparison
          const originalEntries = result.extractedEntries;
          
          for (let i = 0; i < edited.extractedEntries.length; i++) {
            const editedEntry = edited.extractedEntries[i];
            const originalEntry = originalEntries[i] || editedEntry;
            
            // Get the original extracted supplier name (before any matching)
            const originalSupplier = originalEntry.supplier;
            // Get the final supplier name (after user editing)
            const finalSupplierName = editedEntry.editedSupplierName || editedEntry.supplier;
            
            // Skip if no change, or if either is invalid
            if (!originalSupplier || !finalSupplierName || 
                originalSupplier === finalSupplierName ||
                originalSupplier.trim().length === 0 ||
                finalSupplierName.trim().length === 0) {
              continue;
            }
            
            // Only collect entries where the original is shorter than the final name (indicating a correction/expansion)
            if (originalSupplier.trim().length > 0 && 
                finalSupplierName.trim().length > originalSupplier.trim().length) {
              
              // Check if THIS specific initial already exists in database or pending map
              const supplier = allSuppliers.find(s => s.name === finalSupplierName);
              const dbInitials = supplier?.initials || [];
              const pendingInitials = supplierInitialsMap[finalSupplierName] || [];
              const allInitials = [...dbInitials, ...pendingInitials];
              const trimmedInitial = originalSupplier.trim();
              
              // Check if this specific initial already exists (case-insensitive)
              const initialExists = allInitials.some(init => 
                init.trim().toLowerCase() === trimmedInitial.toLowerCase()
              );
              
              if (!initialExists) {
                // Avoid duplicates in the list
                const alreadyInList = initialsToAdd.some(
                  item => item.initial.toLowerCase() === trimmedInitial.toLowerCase() && item.supplierName === finalSupplierName
                );
                if (!alreadyInList) {
                  initialsToAdd.push({
                    initial: trimmedInitial,
                    supplierName: finalSupplierName
                  });
                }
              }
            }
          }
        }
        
        // Show single prompt for all initials if any need to be added
        if (initialsToAdd.length > 0) {
          const initialsList = initialsToAdd.map(item => `"${item.initial}" ‚Üí "${item.supplierName}"`).join('\n');
          const shouldAdd = window.confirm(
            `Add the following supplier initials?\n\n${initialsList}\n\nThis will help match similar suppliers in future extractions.`
          );
          
          if (!shouldAdd) {
            // User cancelled - don't approve, allow them to correct
            return;
          }
          
          // Add all initials to pending map
          setSupplierInitialsMap(prev => {
            const newMap = { ...prev };
            for (const item of initialsToAdd) {
              if (!newMap[item.supplierName]) {
                newMap[item.supplierName] = [];
              }
              if (!newMap[item.supplierName].includes(item.initial)) {
                newMap[item.supplierName] = [...newMap[item.supplierName], item.initial];
              }
            }
            return newMap;
          });
        }
        
        // Determine source based on how the cost was obtained
        let source = 'DESCRIPTION';
        if (hasExtraction) {
          if (selectedEntry && selectedEntry.editedCost !== null && selectedEntry.editedCost !== undefined) {
            source = 'MANUAL_OVERRIDE';
          } else {
            source = 'EXTRACTED_SELECTED';
          }
        } else {
          source = 'MANUAL_INPUT';
        }
        
        try {
          // Prepare extracted entries for supplier cost history
          const entriesToSend = hasExtraction && edited.extractedEntries
            ? edited.extractedEntries.map(entry => ({
                supplier: entry.supplier,
                amount: entry.amount,
                supplierId: entry.supplierId || null,
                editedSupplierName: entry.editedSupplierName || null,
                editedCost: entry.editedCost !== null && entry.editedCost !== undefined ? entry.editedCost : null,
                editedEffectiveDate: entry.editedEffectiveDate || null,
                isSelected: entry.isSelected || false,
              }))
            : [];
          
          // Save approval to database with all extracted entries
          const response = await fetch('/admin/inventory/cutover/approve-item', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              cutoverId: cutoverId,
              productId: result.productId,
              cost: cost,
              source: source,
              notes: supplierName ? `Supplier: ${supplierName}` : null,
              extractedEntries: entriesToSend,
              selectedSupplierId: supplierId,
              selectedSupplierName: supplierName,
            }),
          });
          
          if (!response.ok) {
            const data = await response.json();
            throw new Error(data.message || 'Failed to approve item');
          }
          
          // Save supplier initials if any were learned (use the initials we just added, not the old state)
          if (initialsToAdd.length > 0) {
            try {
              for (const item of initialsToAdd) {
                const initialResponse = await fetch('/admin/inventory/cutover/suppliers/add-initial', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ supplierName: item.supplierName, initial: item.initial }),
                });
                if (!initialResponse.ok) {
                  const errorData = await initialResponse.json();
                  console.error(`Failed to save initial "${item.initial}" for "${item.supplierName}":`, errorData);
                  throw new Error(`Failed to save initial: ${errorData.message || 'Unknown error'}`);
                }
              }
              // Remove the saved initials from the map (keep any others that were pending)
              setSupplierInitialsMap(prev => {
                const newMap = { ...prev };
                for (const item of initialsToAdd) {
                  if (newMap[item.supplierName]) {
                    newMap[item.supplierName] = newMap[item.supplierName].filter(
                      init => init.toLowerCase() !== item.initial.toLowerCase()
                    );
                    if (newMap[item.supplierName].length === 0) {
                      delete newMap[item.supplierName];
                    }
                  }
                }
                return newMap;
              });
              // Refresh suppliers so subsequent items can use the new initials
              const updatedSuppliers = await fetchAllSuppliers();
              
              // Re-match suppliers for all pending extraction results using the fresh supplier list
              if (updatedSuppliers.length > 0) {
                setExtractionResults(prevResults => {
                  return prevResults.map(productResult => {
                    if (productResult.migrationStatus === 'APPROVED' || productResult.migrationStatus === 'SKIPPED') {
                      return productResult; // Don't re-match approved or skipped items
                    }
                    
                    if (productResult.extractedEntries) {
                      // First pass: find all matches
                      const entriesWithMatches = productResult.extractedEntries.map((entry, idx) => {
                        const originalSupplier = entry.supplier;
                        let matchedSupplierName = null;
                        let matchedSupplierId = null;
                        let matchedByInitial = false;
                        
                        const isUnknownOrGeneral = !originalSupplier || originalSupplier === 'Unknown' || originalSupplier === 'General';
                        
                        if (!isUnknownOrGeneral && originalSupplier) {
                          const supplierInitial = originalSupplier.trim().toLowerCase();
                          const matchedByInitialResult = updatedSuppliers.find(s => {
                            const initials = Array.isArray(s.initials) ? s.initials : (s.initials ? [s.initials] : []);
                            return initials.some(init => init.toLowerCase() === supplierInitial) && s.isActive;
                          });
                          
                          if (matchedByInitialResult) {
                            matchedSupplierName = matchedByInitialResult.name;
                            matchedSupplierId = matchedByInitialResult.id;
                            matchedByInitial = true;
                          } else {
                            const matchedByName = updatedSuppliers.find(s => 
                              s.name.toLowerCase() === originalSupplier.toLowerCase() && s.isActive
                            );
                            if (matchedByName) {
                              matchedSupplierName = matchedByName.name;
                              matchedSupplierId = matchedByName.id;
                            }
                          }
                        }
                        
                        return {
                          entry,
                          idx,
                          matchedSupplierName,
                          matchedSupplierId,
                          matchedByInitial,
                        };
                      });
                      
                      // Preserve the backend's selection (last entry is selected by default)
                      // Supplier matching should NOT change which entry is selected
                      
                      // Map entries with selection logic
                      const updatedEntries = productResult.extractedEntries.map((entry, idx) => {
                        const matchInfo = entriesWithMatches[idx];
                        
                        if (matchInfo.matchedSupplierName) {
                          return {
                            ...entry,
                            supplier: matchInfo.entry.supplier,
                            editedSupplierName: matchInfo.matchedSupplierName,
                            supplierId: matchInfo.matchedSupplierId,
                            // Preserve the backend's isSelected flag (last entry is selected by default)
                            isSelected: entry.isSelected !== undefined ? entry.isSelected : (idx === productResult.extractedEntries.length - 1),
                            matchedByInitial: matchInfo.matchedByInitial,
                          };
                        }
                        
                        return {
                          ...entry,
                          // Preserve the backend's isSelected flag (last entry is selected by default)
                          isSelected: entry.isSelected !== undefined ? entry.isSelected : (idx === productResult.extractedEntries.length - 1),
                        };
                      });
                      
                      // Update selectedSupplierName to the selected entry (the one with isSelected: true), or last entry as fallback
                      const selectedEntry = updatedEntries.find(e => e.isSelected) 
                        || updatedEntries[updatedEntries.length - 1];
                      
                      if (selectedEntry) {
                        return {
                          ...productResult,
                          extractedEntries: updatedEntries,
                          selectedSupplierName: selectedEntry.editedSupplierName || selectedEntry.supplier,
                          selectedSupplierId: selectedEntry.supplierId,
                          selectedCost: selectedEntry.editedCost !== null && selectedEntry.editedCost !== undefined 
                            ? selectedEntry.editedCost 
                            : selectedEntry.amount,
                        };
                      }
                      
                      return {
                        ...productResult,
                        extractedEntries: updatedEntries,
                      };
                    }
                    return productResult;
                  });
                });
              }
            } catch (initialsErr) {
              console.warn('Failed to save some supplier initials:', initialsErr);
              // Don't fail the approval if initials save fails
            }
          }
          
          // Update the result to approved status
          setExtractionResults(prev => prev.map(r => 
            r.productId === result.productId ? { 
              ...r, 
              migrationStatus: 'APPROVED',
              selectedCost: cost,
              selectedSupplierName: supplierName,
              selectedSupplierId: supplierId,
            } : r
          ));
          
          // Move to next item if available, otherwise stay at current (which will become last after removal)
          setCurrentExtractingIndex(prev => {
            const currentExtractingCount = extractionResults.filter(r => 
              !r.migrationStatus || r.migrationStatus === 'PENDING'
            ).length;
            // After approval, one item will be removed, so if we're not at the last item, move forward
            // If we're at the last item, stay at current index (it will become the new last item)
            if (prev < currentExtractingCount - 1) {
              return prev; // Stay at same index (next item will move into this position)
            } else {
              // We're at the last item, move to previous if available
              return Math.max(0, prev - 1);
            }
          });
        } catch (err) {
          setError(err.message || 'Failed to approve item');
        }
      };

      // Handler: Start migration
      const handleStartMigration = async () => {
        const pendingItems = extractionResults.filter(r => 
          !r.migrationStatus || r.migrationStatus === 'PENDING'
        );
        if (pendingItems.length > 0) {
          if (!window.confirm(`You have ${pendingItems.length} pending items. Discard them or review?`)) {
            return;
          }
        }
        setLoading(true);
        setError(null);
        setState('migrating');
        try {
          const response = await fetch('/admin/inventory/cutover/initiate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              cutoverDate: cutoverDate + 'T00:00:00Z',
              locationIds: [selectedLocationId],
              costBasis: costBasis,
              ownerApproved: true,
              approvalId: currentCutoverId,
              batchSize: batchSize,
            }),
          });
          const data = await response.json();
          if (data.success) {
            setMigrationResult(data.result);
            if (data.result.isComplete) {
              setReportData(data.result);
              setState('reporting');
            } else {
              handleContinueMigration();
            }
          } else {
            setError(data.message || 'Migration failed');
            setState('extracting');
          }
        } catch (err) {
          setError(err.message || 'Migration failed');
          setState('extracting');
        } finally {
          setLoading(false);
        }
      };

      // Handler: Continue migration batches
      const handleContinueMigration = async () => {
        try {
          const response = await fetch('/admin/inventory/cutover/continue', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ cutoverId: currentCutoverId }),
          });
          const data = await response.json();
          if (data.success) {
            setMigrationResult(data.result);
            if (data.result.isComplete) {
              setReportData(data.result);
              setState('reporting');
            }
          }
        } catch (err) {
          setError(err.message || 'Failed to continue migration');
        }
      };

      // Detect batch completion when all items are approved or discarded
      useEffect(() => {
        // Only check batch complete if we're in extracting state and not loading
        if (state === 'extracting' && !loading) {
          if (extractionResults.length === 0) {
            // No results yet, don't show batch complete
            setBatchComplete(false);
            return;
          }
          
          const extractingItems = extractionResults.filter(r => 
            r.migrationStatus !== 'SKIPPED' && r.migrationStatus !== 'APPROVED'
          );
          
          if (extractingItems.length === 0) {
            // All items are approved or skipped
            console.log('All items processed, setting batch complete');
            setBatchComplete(true);
          } else {
            // Still have items to process
            setBatchComplete(false);
          }
        } else if (loading) {
          // Don't show batch complete while loading
          setBatchComplete(false);
        }
      }, [extractionResults, state, loading]);

      // Fetch CostApproval data for approved items to get supplier from notes
      useEffect(() => {
        const fetchCostApprovals = async () => {
          const approvedItems = extractionResults.filter(r => r.migrationStatus === 'APPROVED');
          if (approvedItems.length === 0) {
            setCostApprovals({});
            return;
          }
          
          const cutoverId = currentCutoverId || extractionResult?.cutoverId || extractionSessionId;
          if (!cutoverId || !extractionSessionId) {
            setCostApprovals({});
            return;
          }
          
          const productIds = approvedItems.map(r => r.productId);
          
          try {
            // Fetch extraction session which includes cost approvals
            const response = await fetch(`/admin/inventory/cutover/extraction-session/${extractionSessionId}`);
            if (!response.ok) {
              setCostApprovals({});
              return;
            }
            
            const sessionData = await response.json();
            if (sessionData.success && sessionData.session) {
              if (sessionData.session.costApprovals && Array.isArray(sessionData.session.costApprovals)) {
                const approvalsMap = {};
                sessionData.session.costApprovals
                  .filter(approval => approval && productIds.includes(approval.productId))
                  .forEach(approval => {
                    approvalsMap[approval.productId] = approval;
                  });
                setCostApprovals(approvalsMap);
              } else {
                // If costApprovals not in session, try to use selectedSupplierName from results
                console.log('Cost approvals not found in session, using selectedSupplierName from results');
                setCostApprovals({});
              }
            } else {
              setCostApprovals({});
            }
          } catch (err) {
            console.error('Failed to fetch cost approvals:', err);
          }
        };
        
        if (extractionTab === 'approved' && extractionResults.length > 0) {
          fetchCostApprovals();
        }
      }, [extractionResults, extractionTab, currentCutoverId, extractionResult?.cutoverId, extractionSessionId]);

      // Group extraction results by status
      const groupedResults = {
        extracting: extractionResults.filter(r => 
          r.migrationStatus !== 'SKIPPED' && r.migrationStatus !== 'APPROVED'
        ),
        approved: extractionResults.filter(r => r.migrationStatus === 'APPROVED'),
        discarded: extractionResults.filter(r => r.migrationStatus === 'SKIPPED'),
      };

      // Render based on state machine
      if (state === 'configuring') {
      return (
        <div className="max-w-4xl mx-auto space-y-6">
            <h2 className="text-2xl font-bold text-gray-900">Inventory Migration - Configuration</h2>
            
            {error && (
              <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg">
                {error}
              </div>
            )}

            <div className="space-y-6">
              {/* Location Selector */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Location <span className="text-red-500">*</span>
                </label>
                <div className="space-y-2">
                  {locations.map(loc => (
                    <label key={loc.id} className="flex items-center p-3 border border-gray-200 rounded-lg hover:bg-gray-50 cursor-pointer">
                      <input
                        type="radio"
                        name="location"
                        value={loc.id}
                        checked={selectedLocationId === loc.id}
                        onChange={(e) => setSelectedLocationId(e.target.value)}
                        className="text-primary focus:ring-primary"
                      />
                      <span className="ml-3 text-sm text-gray-700">{loc.name}</span>
                    </label>
                  ))}
                </div>
              </div>

              {/* Date Picker */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Cutover Date <span className="text-red-500">*</span>
                </label>
                <input
                  type="date"
                  value={cutoverDate}
                  max={new Date().toISOString().split('T')[0]}
                  onChange={(e) => setCutoverDate(e.target.value)}
                  className="block w-full rounded-md border-gray-300 shadow-sm focus:border-primary focus:ring-primary"
                />
              </div>

              {/* Method Selector */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Cost Method <span className="text-red-500">*</span>
                </label>
                <select
                  value={costBasis}
                  onChange={(e) => setCostBasis(e.target.value)}
                  className="block w-full rounded-md border-gray-300 shadow-sm focus:border-primary focus:ring-primary"
                >
                  <option value="DESCRIPTION">Description Extraction</option>
                  <option value="SQUARE_COST">Square Cost</option>
                  <option value="MANUAL_INPUT">Manual Input</option>
                  <option value="AVERAGE_COST">Average Cost</option>
                </select>
              </div>

              {/* Batch Size Input */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Batch Quantity
                </label>
                <input
                  type="number"
                  min="10"
                  max="500"
                  value={batchSize}
                  onChange={(e) => setBatchSize(parseInt(e.target.value) || 50)}
                  className="block w-full rounded-md border-gray-300 shadow-sm focus:border-primary focus:ring-primary"
                />
                <p className="mt-1 text-xs text-gray-500">Between 10 and 500 items per batch</p>
              </div>

              <button
                onClick={handleStartExtraction}
                disabled={loading || !selectedLocationId}
                className="w-full px-4 py-2 bg-primary hover:bg-primary-hover text-white rounded-md font-medium disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {loading ? 'Starting...' : 'Start Extraction Session'}
              </button>
            </div>

            {/* Session Selector Modal */}
            {showSessionSelector && (
            <div style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              backgroundColor: 'rgba(0, 0, 0, 0.5)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 1000,
            }}>
              <div style={{
                backgroundColor: 'white',
                borderRadius: '8px',
                padding: '24px',
                maxWidth: '600px',
                width: '90%',
                maxHeight: '80vh',
                overflow: 'auto',
              }}>
                <h3 style={{ marginTop: 0, marginBottom: '16px', fontSize: '18px', fontWeight: '600' }}>
                  Resume Existing Session or Start New?
                </h3>
                
                {existingSessions.length > 0 && (
                  <div style={{ marginBottom: '20px' }}>
                    <h4 style={{ marginBottom: '12px', fontSize: '14px', fontWeight: '600', color: '#374151' }}>
                      In-Progress Sessions ({existingSessions.length})
                    </h4>
                    <div style={{ 
                      border: '1px solid #e5e7eb', 
                      borderRadius: '6px',
                      maxHeight: '300px',
                      overflow: 'auto',
                    }}>
                      {existingSessions.map(session => (
                        <div
                          key={session.id}
                          onClick={() => handleResumeSession(session.id)}
                          style={{
                            padding: '12px 16px',
                            borderBottom: '1px solid #f3f4f6',
                            cursor: 'pointer',
                            transition: 'background-color 0.2s',
                          }}
                          onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#f9fafb'}
                          onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'white'}
                        >
                          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <div>
                              <div style={{ fontWeight: '500', marginBottom: '4px', fontSize: '14px' }}>
                                Session from {new Date(session.createdAt).toLocaleString()}
                              </div>
                              <div style={{ fontSize: '12px', color: '#6b7280' }}>
                                Batch {session.currentBatch} of {session.totalBatches || '?'} ‚Ä¢ 
                                {' '}{session.processedItems} / {session.totalItems} items processed ‚Ä¢ 
                                {' '}{session.batchCount} batches extracted
                              </div>
                            </div>
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                handleResumeSession(session.id);
                              }}
                              style={{
                                padding: '6px 12px',
                                backgroundColor: '#3b82f6',
                                color: 'white',
                                border: 'none',
                                borderRadius: '4px',
                                cursor: 'pointer',
                                fontSize: '12px',
                                fontWeight: '500',
                              }}
                            >
                              Resume
                            </button>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
                
                <div style={{ display: 'flex', gap: '12px', justifyContent: 'flex-end' }}>
                  <button
                    onClick={() => {
                      setShowSessionSelector(false);
                      // Proceed with new extraction
                      handleStartNewExtraction();
                    }}
                    style={{
                      padding: '8px 16px',
                      backgroundColor: '#6b7280',
                      color: 'white',
                      border: 'none',
                      borderRadius: '4px',
                      cursor: 'pointer',
                      fontSize: '14px',
                      fontWeight: '500',
                    }}
                  >
                    Start New Session
                  </button>
                  <button
                    onClick={() => setShowSessionSelector(false)}
                    style={{
                      padding: '8px 16px',
                      backgroundColor: '#e5e7eb',
                      color: '#374151',
                      border: 'none',
                      borderRadius: '4px',
                      cursor: 'pointer',
                      fontSize: '14px',
                      fontWeight: '500',
                    }}
                  >
                    Cancel
                  </button>
                </div>
              </div>
            </div>
          )}
          </div>
        );
      }

      // Phase 2: Extraction Workspace
      if (state === 'extracting' || state === 'reviewing') {
        const totalItems = extractionResults.length;
        const remainingItems = groupedResults.extracting.length;
        const progress = totalItems > 0 ? ((totalItems - remainingItems) / totalItems * 100) : 0;

        return (
          <div className="max-w-6xl mx-auto space-y-6">
            <h2 className="text-2xl font-bold text-gray-900">Extraction Workspace</h2>
            
            {error && (
              <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg">
                {error}
              </div>
            )}

            {/* Header Stats */}
            <div className="bg-gray-50 rounded-lg p-4 flex items-center justify-between">
              <div className="flex gap-4">
                <span className="px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm font-medium">
                  Total Items: {totalItems}
                </span>
                <span className="px-3 py-1 bg-yellow-100 text-yellow-800 rounded-full text-sm font-medium">
                  Remaining: {remainingItems}
                </span>
              </div>
              <div className="flex-1 mx-4">
                <div className="bg-gray-200 rounded-full h-2">
                  <div 
                    className="bg-blue-600 h-2 rounded-full transition-all"
                    style={{ width: `${progress}%` }}
                  />
                </div>
              </div>
              <div className="flex gap-2">
                <button
                  onClick={() => setState('configuring')}
                  className="px-4 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 bg-white hover:bg-gray-50"
                >
                  Pause & Exit
                </button>
              </div>
            </div>

            {/* Tabs */}
            <div className="border-b border-gray-200">
              <div className="flex gap-2">
                <button
                  onClick={() => {
                    setExtractionTab('extracting');
                    setCurrentExtractingIndex(0); // Reset to first item when switching to extracting tab
                  }}
                  className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors ${
                    extractionTab === 'extracting'
                      ? 'border-primary text-primary font-semibold'
                      : 'border-transparent text-gray-600 hover:text-primary'
                  }`}
                >
                  Extracting / Action Needed ({groupedResults.extracting.length})
                </button>
                <button
                  onClick={() => setExtractionTab('approved')}
                  className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors ${
                    extractionTab === 'approved'
                      ? 'border-primary text-primary font-semibold'
                      : 'border-transparent text-gray-600 hover:text-primary'
                  }`}
                >
                  Approved ({groupedResults.approved.length})
                </button>
                <button
                  onClick={() => setExtractionTab('discarded')}
                  className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors ${
                    extractionTab === 'discarded'
                      ? 'border-primary text-primary font-semibold'
                      : 'border-transparent text-gray-600 hover:text-primary'
                  }`}
                >
                  Discarded / Skipped ({groupedResults.discarded.length})
                </button>
              </div>
            </div>

            {/* Tab Content */}
            <div className="space-y-4">
              {extractionTab === 'extracting' && (
                <div className="space-y-4">
                  {groupedResults.extracting.length > 0 ? (
                    (() => {
                      const result = groupedResults.extracting[currentExtractingIndex];
                      if (!result) {
                        // Reset index if out of bounds
                        if (currentExtractingIndex >= groupedResults.extracting.length) {
                          setCurrentExtractingIndex(Math.max(0, groupedResults.extracting.length - 1));
                        }
                        return null;
                      }
                      
                      const edited = editedResults[result.productId] || result;
                      const hasExtraction = edited.extractedEntries && edited.extractedEntries.length > 0;
                      const selectedEntry = edited.extractedEntries?.find(e => e.isSelected) || 
                        (edited.extractedEntries?.length > 0 ? edited.extractedEntries[edited.extractedEntries.length - 1] : null);
                      const displayCost = edited.selectedCost !== null && edited.selectedCost !== undefined 
                        ? edited.selectedCost 
                        : (selectedEntry ? (selectedEntry.editedCost !== null && selectedEntry.editedCost !== undefined ? selectedEntry.editedCost : selectedEntry.amount) : null);
                      const displaySupplier = edited.selectedSupplierName || (selectedEntry ? (selectedEntry.editedSupplierName || selectedEntry.supplier) : null) || '';

                    return (
                      <div key={result.productId} className="space-y-4">
                      <div className="border border-gray-200 rounded-lg bg-white">
                        <div className="grid grid-cols-3 gap-6 p-6">
                          {/* Left Column: Extracted Costs Table */}
                          <div className="space-y-4 col-span-2">
                            {/* Header with count badge */}
                            <div className="flex items-center justify-between">
                              <div>
                                <h3 className="text-lg font-semibold text-gray-900">Extracted Costs</h3>
                                <p className="text-sm text-gray-600">Select the most accurate cost entry from the list below.</p>
                              </div>
                              {hasExtraction && (
                                <span className="px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm font-medium">
                                  {edited.extractedEntries?.length || 0} Found
                                </span>
                              )}
                            </div>
                            <div>
                              <h3 className="font-semibold text-gray-900 text-lg">{result.productName}</h3>
                              {result.originalDescription && result.originalDescription !== result.productName && (
                                <p className="text-sm text-gray-500 mt-1">{result.originalDescription}</p>
                              )}
                            </div>

                            {/* Extracted Entries Table */}
                            {hasExtraction ? (
                              <div className="border border-gray-200 rounded-lg overflow-hidden">
                                <table className="w-full">
                                  <thead className="bg-gray-50">
                                    <tr>
                                      <th className="px-4 py-3 text-left text-xs font-medium text-gray-700 w-12"></th>
                                      <th className="px-4 py-3 text-left text-xs font-medium text-gray-700">SUPPLIER NAME</th>
                                      <th className="px-4 py-3 text-left text-xs font-medium text-gray-700">COST</th>
                                      <th className="px-4 py-3 text-left text-xs font-medium text-gray-700">DATE</th>
                                      <th className="px-4 py-3 text-left text-xs font-medium text-gray-700">SOURCE</th>
                                    </tr>
                                  </thead>
                                  <tbody className="divide-y divide-gray-200 bg-white">
                                    {edited.extractedEntries.map((entry, idx) => {
                                      const isSelected = entry.isSelected !== undefined ? entry.isSelected : (idx === edited.extractedEntries.length - 1);
                                      const entryKey = `${result.productId}_${idx}`;
                                      const suggestions = supplierSuggestions[entryKey] || [];
                                      const showAutocomplete = openAutocomplete[entryKey];

                                      return (
                                        <tr key={idx} className={isSelected ? 'bg-blue-50' : 'hover:bg-gray-50'}>
                                          {/* Radio button column */}
                                          <td className="px-4 py-3">
                                            <input
                                              type="radio"
                                              name={`entry_${result.productId}`}
                                              checked={isSelected}
                                              onChange={() => {
                                                setEditedResults(prev => {
                                                  const newResults = { ...prev };
                                                  if (!newResults[result.productId]) {
                                                    newResults[result.productId] = { ...result };
                                                  }
                                                  if (!newResults[result.productId].extractedEntries) {
                                                    newResults[result.productId].extractedEntries = [...result.extractedEntries];
                                                  }
                                                  // Unselect all entries
                                                  newResults[result.productId].extractedEntries = newResults[result.productId].extractedEntries.map((e, i) => ({
                                                    ...e,
                                                    isSelected: i === idx
                                                  }));
                                                  // Update selected cost and supplier
                                                  newResults[result.productId].selectedCost = entry.editedCost !== null && entry.editedCost !== undefined ? entry.editedCost : entry.amount;
                                                  newResults[result.productId].selectedSupplierName = entry.editedSupplierName || entry.supplier;
                                                  newResults[result.productId].selectedSupplierId = entry.supplierId;
                                                  return newResults;
                                                });
                                              }}
                                              className="w-4 h-4 text-primary"
                                            />
                                          </td>
                                          
                                          {/* Supplier Name column - editable with dropdown */}
                                          <td className="px-4 py-3">
                                            <div className="relative">
                                              <input
                                                type="text"
                                                value={entry.editedSupplierName ?? entry.supplier ?? ''}
                                                onChange={(e) => {
                                                  const newValue = e.target.value;
                                                  
                                                  setEditedResults(prev => {
                                                    const newResults = { ...prev };
                                                    if (!newResults[result.productId]) {
                                                      newResults[result.productId] = { ...result };
                                                    }
                                                    if (!newResults[result.productId].extractedEntries) {
                                                      newResults[result.productId].extractedEntries = [...result.extractedEntries];
                                                    }
                                                    newResults[result.productId].extractedEntries[idx] = {
                                                      ...newResults[result.productId].extractedEntries[idx],
                                                      editedSupplierName: newValue,
                                                    };
                                                    if (isSelected) {
                                                      newResults[result.productId].selectedSupplierName = newValue;
                                                    }
                                                    return newResults;
                                                  });
                                                  
                                                  // Show autocomplete
                                                  const localSuggestions = getSupplierSuggestions(newValue, entry.supplier);
                                                  if (localSuggestions.length > 0) {
                                                    setOpenAutocomplete(prev => ({ ...prev, [entryKey]: true }));
                                                    setSupplierSuggestions(prev => ({ ...prev, [entryKey]: localSuggestions }));
                                                  } else if (newValue.length > 1) {
                                                    fetch(`/admin/inventory/cutover/suppliers/suggest?q=${encodeURIComponent(newValue)}`)
                                                      .then(res => res.json())
                                                      .then(data => {
                                                        if (data.success) {
                                                          setOpenAutocomplete(prev => ({ ...prev, [entryKey]: true }));
                                                          setSupplierSuggestions(prev => ({ ...prev, [entryKey]: data.suppliers }));
                                                        }
                                                      })
                                                      .catch(err => console.error('Failed to fetch suggestions:', err));
                                                  } else {
                                                    setOpenAutocomplete(prev => {
                                                      const newState = { ...prev };
                                                      delete newState[entryKey];
                                                      return newState;
                                                    });
                                                  }
                                                }}
                                                onBlur={() => {
                                                  setTimeout(() => {
                                                    if (!dropdownSelectionRef.current[entryKey]) {
                                                      setOpenAutocomplete(prev => {
                                                        const newState = { ...prev };
                                                        delete newState[entryKey];
                                                        return newState;
                                                      });
                                                    }
                                                    dropdownSelectionRef.current[entryKey] = false;
                                                  }, 200);
                                                }}
                                                className={`w-full px-2 py-1 border rounded text-sm focus:outline-none focus:ring-2 focus:ring-primary ${
                                                  isSelected ? 'border-blue-500 bg-blue-50' : 'border-gray-300'
                                                }`}
                                                placeholder="Supplier name"
                                              />
                                              {/* Show "Matched by initial: X" below if applicable */}
                                              {entry.matchedByInitial && (
                                                <div className="text-xs text-blue-600 mt-1">
                                                  Matched by initial: {entry.supplier}
                                                </div>
                                              )}
                                              {/* Autocomplete dropdown */}
                                              {showAutocomplete && suggestions.length > 0 && (
                                                <div className="absolute z-20 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-auto">
                                                  {suggestions.map((suggestion, sIdx) => (
                                                    <div
                                                      key={sIdx}
                                                      className="px-3 py-2 hover:bg-gray-100 cursor-pointer text-sm"
                                                      onMouseDown={() => {
                                                        dropdownSelectionRef.current[entryKey] = true;
                                                        setEditedResults(prev => {
                                                          const newResults = { ...prev };
                                                          if (!newResults[result.productId]) {
                                                            newResults[result.productId] = { ...result };
                                                          }
                                                          if (!newResults[result.productId].extractedEntries) {
                                                            newResults[result.productId].extractedEntries = [...result.extractedEntries];
                                                          }
                                                          newResults[result.productId].extractedEntries[idx] = {
                                                            ...newResults[result.productId].extractedEntries[idx],
                                                            editedSupplierName: suggestion.name,
                                                            supplierId: suggestion.id,
                                                          };
                                                          if (isSelected) {
                                                            newResults[result.productId].selectedSupplierName = suggestion.name;
                                                            newResults[result.productId].selectedSupplierId = suggestion.id;
                                                          }
                                                          return newResults;
                                                        });
                                                        setOpenAutocomplete(prev => {
                                                          const newState = { ...prev };
                                                          delete newState[entryKey];
                                                          return newState;
                                                        });
                                                      }}
                                                    >
                                                      <div className="font-medium">{suggestion.name}</div>
                                                      {suggestion.contactInfo && (
                                                        <div className="text-xs text-gray-500">{suggestion.contactInfo}</div>
                                                      )}
                                                    </div>
                                                  ))}
                                                </div>
                                              )}
                                            </div>
                                          </td>
                                          
                                          {/* Cost column - editable */}
                                          <td className="px-4 py-3">
                                            <input
                                              type="number"
                                              step="0.01"
                                              min="0"
                                              value={entry.editedCost !== null && entry.editedCost !== undefined ? entry.editedCost : entry.amount}
                                              onChange={(e) => {
                                                const newCost = parseFloat(e.target.value) || 0;
                                                if (newCost < 0) {
                                                  setError('Cost cannot be negative');
                                                  return;
                                                }
                                                if (newCost === 0) {
                                                  if (!window.confirm('Cost is zero. Are you sure?')) {
                                                    return;
                                                  }
                                                }
                                                setEditedResults(prev => {
                                                  const newResults = { ...prev };
                                                  if (!newResults[result.productId]) {
                                                    newResults[result.productId] = { ...result };
                                                  }
                                                  if (!newResults[result.productId].extractedEntries) {
                                                    newResults[result.productId].extractedEntries = [...result.extractedEntries];
                                                  }
                                                  newResults[result.productId].extractedEntries[idx] = {
                                                    ...newResults[result.productId].extractedEntries[idx],
                                                    editedCost: newCost,
                                                  };
                                                  if (isSelected) {
                                                    newResults[result.productId].selectedCost = newCost;
                                                  }
                                                  return newResults;
                                                });
                                              }}
                                              className={`w-full px-2 py-1 border rounded text-sm focus:outline-none focus:ring-2 focus:ring-primary ${
                                                isSelected ? 'border-blue-500 bg-blue-50' : 'border-gray-300'
                                              }`}
                                            />
                                          </td>
                                          
                                          {/* Date column - editable date input */}
                                          <td className="px-4 py-3">
                                            {(() => {
                                              // Extract date from month and year in originalLine
                                              let extractedDate = null;
                                              
                                              // If we have a month extracted, try to construct date
                                              if (entry.month) {
                                                // Try to extract year from originalLine (look for 4-digit year like 2015, 2014, etc.)
                                                let year = null;
                                                const yearMatch = entry.originalLine?.match(/\b(19|20)\d{2}\b/);
                                                
                                                if (yearMatch) {
                                                  year = parseInt(yearMatch[0]);
                                                } else if (cutoverDate) {
                                                  // If no year in text, use cutover date year as default
                                                  // This handles cases like "Mx $20.35 mayo" where year is not explicit
                                                  year = new Date(cutoverDate).getFullYear();
                                                }
                                                
                                                if (year) {
                                                  // Map month name to month number (0-11 for JavaScript Date)
                                                  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                                                                    'July', 'August', 'September', 'October', 'November', 'December'];
                                                  const monthIndex = monthNames.indexOf(entry.month);
                                                  
                                                  if (monthIndex !== -1) {
                                                    // Create date: first day of the month
                                                    const date = new Date(year, monthIndex, 1);
                                                    extractedDate = date.toISOString().split('T')[0];
                                                  }
                                                }
                                              }
                                              
                                              // Priority: user-edited date > extracted date > cutover date > today
                                              // But if editedEffectiveDate is today (likely default from backend), prefer extracted date
                                              const todayString = new Date().toISOString().split('T')[0];
                                              const isDefaultDate = entry.editedEffectiveDate === todayString;
                                              
                                              const displayDate = (!isDefaultDate && entry.editedEffectiveDate) 
                                                ? entry.editedEffectiveDate 
                                                : (extractedDate || cutoverDate || todayString);
                                              
                                              return (
                                                <input
                                                  type="date"
                                                  value={displayDate}
                                                  onChange={(e) => {
                                                    const newDate = e.target.value;
                                                    setEditedResults(prev => {
                                                      const newResults = { ...prev };
                                                      if (!newResults[result.productId]) {
                                                        newResults[result.productId] = { ...result };
                                                      }
                                                      if (!newResults[result.productId].extractedEntries) {
                                                        newResults[result.productId].extractedEntries = [...result.extractedEntries];
                                                      }
                                                      newResults[result.productId].extractedEntries[idx] = {
                                                        ...newResults[result.productId].extractedEntries[idx],
                                                        editedEffectiveDate: newDate,
                                                      };
                                                      return newResults;
                                                    });
                                                  }}
                                                  className={`w-full px-2 py-1 border rounded text-sm focus:outline-none focus:ring-2 focus:ring-primary ${
                                                    isSelected ? 'border-blue-500 bg-blue-50' : 'border-gray-300'
                                                  }`}
                                                />
                                              );
                                            })()}
                                          </td>
                                          
                                          {/* Source column - original text */}
                                          <td className="px-4 py-3 text-sm text-gray-600">
                                            {entry.originalLine || `$${entry.amount.toFixed(2)}`}
                                          </td>
                                        </tr>
                                      );
                                    })}
                                  </tbody>
                                </table>
                              </div>
                            ) : (
                              /* Manual Input for items without extraction */
                              <div className="space-y-3 border border-red-200 bg-red-50 rounded-lg p-4">
                                <div className="flex items-start gap-2">
                                  <span className="text-red-600">‚ö†Ô∏è</span>
            <div className="flex-1">
                                    <p className="text-sm font-medium text-red-800 mb-2">No cost extracted - manual input required</p>
                                    
                                    {/* Manual Supplier Input */}
                                    <div className="autocomplete-container relative mb-3">
                                      <label className="block text-xs text-gray-700 mb-1">Supplier Name *</label>
                                      <input
                                        type="text"
                                        value={edited.selectedSupplierName ?? ''}
                                        onChange={(e) => {
                                          const newValue = e.target.value;
                                          setEditedResults(prev => {
                                            const newResults = { ...prev };
                                            if (!newResults[result.productId]) {
                                              newResults[result.productId] = { ...result };
                                            }
                                            newResults[result.productId].selectedSupplierName = newValue;
                                            return newResults;
                                          });
                                          
                                          const localSuggestions = getSupplierSuggestions(newValue, '');
                                          if (localSuggestions.length > 0) {
                                            setOpenAutocomplete(prev => ({ ...prev, [result.productId]: true }));
                                            setSupplierSuggestions(prev => ({ ...prev, [result.productId]: localSuggestions }));
                                          } else if (newValue.length > 1) {
                                            fetch(`/admin/inventory/cutover/suppliers/suggest?q=${encodeURIComponent(newValue)}`)
                                              .then(res => res.json())
                                              .then(data => {
                                                if (data.success) {
                                                  setOpenAutocomplete(prev => ({ ...prev, [result.productId]: true }));
                                                  setSupplierSuggestions(prev => ({ ...prev, [result.productId]: data.suppliers }));
                                                }
                                              });
                                          } else {
                                            setOpenAutocomplete(prev => {
                                              const newState = { ...prev };
                                              delete newState[result.productId];
                                              return newState;
                                            });
                                          }
                                        }}
                                        onBlur={() => {
                                          setTimeout(() => {
                                            if (!dropdownSelectionRef.current[result.productId]) {
                                              setOpenAutocomplete(prev => {
                                                const newState = { ...prev };
                                                delete newState[result.productId];
                                                return newState;
                                              });
                                            }
                                            dropdownSelectionRef.current[result.productId] = false;
                                          }, 200);
                                        }}
                                        className="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary"
                                        placeholder="Enter supplier name"
                                      />
                                      {openAutocomplete[result.productId] && supplierSuggestions[result.productId] && supplierSuggestions[result.productId].length > 0 && (
                                        <div className="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-auto">
                                          {supplierSuggestions[result.productId].map((suggestion, sIdx) => (
                                            <div
                                              key={sIdx}
                                              className="px-3 py-2 hover:bg-gray-100 cursor-pointer text-sm"
                                              onMouseDown={() => {
                                                dropdownSelectionRef.current[result.productId] = true;
                                                setEditedResults(prev => {
                                                  const newResults = { ...prev };
                                                  if (!newResults[result.productId]) {
                                                    newResults[result.productId] = { ...result };
                                                  }
                                                  newResults[result.productId].selectedSupplierName = suggestion.name;
                                                  newResults[result.productId].selectedSupplierId = suggestion.id;
                                                  return newResults;
                                                });
                                                setOpenAutocomplete(prev => {
                                                  const newState = { ...prev };
                                                  delete newState[result.productId];
                                                  return newState;
                                                });
                                              }}
                                            >
                                              <div className="font-medium">{suggestion.name}</div>
                                              {suggestion.contactInfo && (
                                                <div className="text-xs text-gray-500">{suggestion.contactInfo}</div>
                                              )}
                                            </div>
                                          ))}
                                        </div>
                                      )}
                                    </div>

                                    {/* Manual Cost Input */}
                                    <div>
                                      <label className="block text-xs text-gray-700 mb-1">Cost *</label>
                                      <input
                                        type="number"
                                        step="0.01"
                                        min="0"
                                        value={edited.selectedCost || ''}
                                        onChange={(e) => {
                                          const newCost = parseFloat(e.target.value) || 0;
                                          if (newCost < 0) {
                                            setError('Cost cannot be negative');
                                            return;
                                          }
                                          if (newCost === 0) {
                                            if (!window.confirm('Cost is zero. Are you sure?')) {
                                              return;
                                            }
                                          }
                                          setEditedResults(prev => {
                                            const newResults = { ...prev };
                                            if (!newResults[result.productId]) {
                                              newResults[result.productId] = { ...result };
                                            }
                                            newResults[result.productId].selectedCost = newCost;
                                            return newResults;
                                          });
                                        }}
                                        className="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary"
                                        placeholder="Enter cost"
                                      />
                                    </div>
                                  </div>
                                </div>
                              </div>
                            )}

                          </div>

                          {/* Right Column: Product Review */}
                          <div className="space-y-4">
                            <h3 className="text-lg font-semibold text-gray-900 uppercase tracking-wide">Product Review</h3>
                            
                            {/* Product Info */}
                            <div>
                              <h4 className="font-semibold text-gray-900 text-base">{result.productName}</h4>
                              {result.originalDescription && result.originalDescription !== result.productName && (
                                <p className="text-sm text-gray-600 mt-1">{result.originalDescription}</p>
                              )}
                              {/* Product Image */}
                              <div className="mt-4 bg-gray-100 rounded-lg p-8 flex items-center justify-center min-h-[200px]">
                                {result.imageUrl ? (
                                  <img src={result.imageUrl} alt={result.productName} className="max-w-full max-h-48 object-contain" />
                                ) : (
                                  <div className="text-gray-400 text-sm">No image available</div>
                                )}
                              </div>
                            </div>
                            
                            {/* Currently Selected Card */}
                            <div className="border border-gray-200 rounded-lg p-4 bg-gray-50">
                              <h5 className="text-sm font-semibold text-gray-700 mb-3 uppercase">Currently Selected</h5>
                              <div className="space-y-2">
                                <div>
                                  <span className="text-xs text-gray-600">Supplier:</span>
                                  <span className="ml-2 font-medium text-gray-900">{displaySupplier || 'Not selected'}</span>
                                </div>
                                <div>
                                  <span className="text-xs text-gray-600">Cost:</span>
                                  <span className="ml-2 font-bold text-lg text-gray-900">
                                    ${displayCost !== null && displayCost !== undefined ? displayCost.toFixed(2) : '0.00'}
                                  </span>
                                </div>
                              </div>
                            </div>
                            
                            {/* Preferred Supplier Override */}
                            {hasExtraction && (
                              <div>
                                <label className="block text-sm font-medium text-gray-700 mb-2">Preferred Supplier Override</label>
                                <select
                                  value={edited.selectedSupplierName || displaySupplier || ''}
                                  onChange={(e) => {
                                    const selectedName = e.target.value;
                                    const selectedSupplier = allSuppliers.find(s => s.name === selectedName);
                                    setEditedResults(prev => {
                                      const newResults = { ...prev };
                                      if (!newResults[result.productId]) {
                                        newResults[result.productId] = { ...result };
                                      }
                                      newResults[result.productId].selectedSupplierName = selectedName;
                                      newResults[result.productId].selectedSupplierId = selectedSupplier?.id || null;
                                      return newResults;
                                    });
                                  }}
                                  className="w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary"
                                >
                                  <option value="">Select preferred supplier</option>
                                  {allSuppliers.filter(s => s.isActive).map(supplier => (
                                    <option key={supplier.id} value={supplier.name}>
                                      {supplier.name}
                                    </option>
                                  ))}
                                </select>
                              </div>
                            )}
                            
                            {/* Action Buttons */}
                            <div className="flex gap-3 pt-4">
                              <button
                                onClick={() => handleApproveItem(result)}
                                className="flex-1 px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-md font-medium"
                              >
                                Approve
                              </button>
                              <button
                                onClick={() => handleDiscardItem(result.productId)}
                                className="flex-1 px-4 py-2 border border-red-600 text-red-600 hover:bg-red-50 rounded-md font-medium"
                              >
                                Discard
                              </button>
                            </div>
                          </div>
                        </div>
                      </div>
                      
                      {/* Navigation and counter */}
                      {groupedResults.extracting.length > 0 && (
                        <div className="flex items-center justify-between p-4 bg-gray-50 rounded-lg border border-gray-200">
                          <div className="flex items-center gap-4">
                            <button
                              onClick={() => setCurrentExtractingIndex(prev => Math.max(0, prev - 1))}
                              disabled={currentExtractingIndex === 0}
                              className={`px-4 py-2 rounded-md font-medium text-sm ${
                                currentExtractingIndex === 0
                                  ? 'bg-gray-200 text-gray-400 cursor-not-allowed'
                                  : 'bg-blue-600 text-white hover:bg-blue-700'
                              }`}
                            >
                              ‚Üê Previous
                            </button>
                            <span className="text-sm font-medium text-gray-700">
                              Item {currentExtractingIndex + 1} of {groupedResults.extracting.length}
                            </span>
                            <button
                              onClick={() => setCurrentExtractingIndex(prev => Math.min(groupedResults.extracting.length - 1, prev + 1))}
                              disabled={currentExtractingIndex >= groupedResults.extracting.length - 1}
                              className={`px-4 py-2 rounded-md font-medium text-sm ${
                                currentExtractingIndex >= groupedResults.extracting.length - 1
                                  ? 'bg-gray-200 text-gray-400 cursor-not-allowed'
                                  : 'bg-blue-600 text-white hover:bg-blue-700'
                              }`}
                            >
                              Next ‚Üí
                            </button>
                          </div>
                        </div>
                      )}
                      </div>
                    );
                    })()
                  ) : (
                    <div className="text-center py-8 text-gray-500">
                      No items need action
                    </div>
                  )}
                </div>
              )}

              {extractionTab === 'approved' && (
                <div className="space-y-4">
                  {groupedResults.approved.map(result => {
                    const isEditing = editingApprovedItem === result.productId;
                    const edited = editedResults[result.productId] || result;
                    
                    // Get supplier from CostApproval notes (format: "Supplier: {name}")
                    let supplierName = null;
                    const approval = costApprovals[result.productId];
                    
                    if (approval && approval.notes) {
                      const match = approval.notes.match(/Supplier:\s*(.+)/i);
                      if (match && match[1]) {
                        supplierName = match[1].trim();
                      }
                    }
                    
                    if (!supplierName) {
                      supplierName = result.selectedSupplierName;
                    }
                    
                    const currentCost = edited.selectedCost !== null && edited.selectedCost !== undefined 
                      ? edited.selectedCost 
                      : result.selectedCost;
                    const currentSupplier = edited.selectedSupplierName || supplierName;
                    
                    return (
                      <div key={result.productId} className="border border-gray-200 rounded-lg p-4 bg-gray-50">
                        <div className="flex items-start gap-4">
                          {result.imageUrl && (
                            <img src={result.imageUrl} alt={result.productName} className="w-20 h-20 object-cover rounded opacity-75" />
                          )}
                          <div className="flex-1">
                            <h3 className="font-semibold text-gray-900">{result.productName}</h3>
                            <div className="mt-2 space-y-3">
                              <p className="text-sm text-gray-600">Status: <span className="text-green-600 font-medium">Approved</span></p>
                              
                              {/* Cost - editable */}
                              <div>
                                <label className="text-xs text-gray-600 font-medium">Cost:</label>
                                {isEditing ? (
                                  <input
                                    type="number"
                                    step="0.01"
                                    min="0"
                                    value={currentCost || ''}
                                    onChange={(e) => {
                                      const newCost = parseFloat(e.target.value) || 0;
                                      setEditedResults(prev => {
                                        const newEdited = { ...prev };
                                        if (!newEdited[result.productId]) {
                                          newEdited[result.productId] = { ...result };
                                        }
                                        newEdited[result.productId].selectedCost = newCost;
                                        return newEdited;
                                      });
                                    }}
                                    className="mt-1 w-full px-2 py-1 border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-primary"
                                  />
                                ) : (
                                  <p className="text-sm text-gray-700 mt-1">
                                    ${typeof currentCost === 'number' ? currentCost.toFixed(2) : parseFloat(currentCost || 0).toFixed(2)}
                                  </p>
                                )}
            </div>
                              
                              {/* Supplier - editable */}
                              <div>
                                <label className="text-xs text-gray-600 font-medium">Supplier:</label>
                                {isEditing ? (
                                  <div className="relative mt-1">
                                    <input
                                      type="text"
                                      value={edited.selectedSupplierName ?? currentSupplier ?? ''}
                                      onChange={(e) => {
                                        const newValue = e.target.value;
                                        setEditedResults(prev => {
                                          const newEdited = { ...prev };
                                          if (!newEdited[result.productId]) {
                                            newEdited[result.productId] = { ...result };
                                          }
                                          newEdited[result.productId].selectedSupplierName = newValue;
                                          return newEdited;
                                        });
                                        
                                        // Show autocomplete
                                        const localSuggestions = getSupplierSuggestions(newValue, '');
                                        if (localSuggestions.length > 0) {
                                          setOpenAutocomplete(prev => ({ ...prev, [`approved_${result.productId}`]: true }));
                                          setSupplierSuggestions(prev => ({ ...prev, [`approved_${result.productId}`]: localSuggestions }));
                                        } else if (newValue.length > 1) {
                                          fetch(`/admin/inventory/cutover/suppliers/suggest?q=${encodeURIComponent(newValue)}`)
                                            .then(res => res.json())
                                            .then(data => {
                                              if (data.success) {
                                                setOpenAutocomplete(prev => ({ ...prev, [`approved_${result.productId}`]: true }));
                                                setSupplierSuggestions(prev => ({ ...prev, [`approved_${result.productId}`]: data.suppliers }));
                                              }
                                            });
                                        } else {
                                          setOpenAutocomplete(prev => {
                                            const newState = { ...prev };
                                            delete newState[`approved_${result.productId}`];
                                            return newState;
                                          });
                                        }
                                      }}
                                      onBlur={() => {
                                        setTimeout(() => {
                                          if (!dropdownSelectionRef.current[`approved_${result.productId}`]) {
                                            setOpenAutocomplete(prev => {
                                              const newState = { ...prev };
                                              delete newState[`approved_${result.productId}`];
                                              return newState;
                                            });
                                          }
                                          dropdownSelectionRef.current[`approved_${result.productId}`] = false;
                                        }, 200);
                                      }}
                                      className="w-full px-2 py-1 border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-primary"
                                      placeholder="Enter supplier name"
                                    />
                                    {openAutocomplete[`approved_${result.productId}`] && supplierSuggestions[`approved_${result.productId}`] && supplierSuggestions[`approved_${result.productId}`].length > 0 && (
                                      <div className="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-auto">
                                        {supplierSuggestions[`approved_${result.productId}`].map((suggestion, sIdx) => (
                                          <div
                                            key={sIdx}
                                            className="px-3 py-2 hover:bg-gray-100 cursor-pointer text-sm"
                                            onMouseDown={() => {
                                              dropdownSelectionRef.current[`approved_${result.productId}`] = true;
                                              setEditedResults(prev => {
                                                const newEdited = { ...prev };
                                                if (!newEdited[result.productId]) {
                                                  newEdited[result.productId] = { ...result };
                                                }
                                                newEdited[result.productId].selectedSupplierName = suggestion.name;
                                                newEdited[result.productId].selectedSupplierId = suggestion.id;
                                                return newEdited;
                                              });
                                              setOpenAutocomplete(prev => {
                                                const newState = { ...prev };
                                                delete newState[`approved_${result.productId}`];
                                                return newState;
                                              });
                                            }}
                                          >
                                            <div className="font-medium">{suggestion.name}</div>
                                            {suggestion.contactInfo && (
                                              <div className="text-xs text-gray-500">{suggestion.contactInfo}</div>
                                            )}
            </div>
                                        ))}
          </div>
                                    )}
                                  </div>
                                ) : (
                                  <p className="text-sm text-gray-700 mt-1">
                                    {currentSupplier || 'Not specified'}
                                  </p>
                                )}
                              </div>
                            </div>
                          </div>
                          <div className="flex flex-col gap-2">
                            {isEditing ? (
                              <>
                                <button
                                  onClick={async () => {
                                    // Save changes by re-approving with new values
                                    const edited = editedResults[result.productId] || result;
                                    const newCost = edited.selectedCost !== null && edited.selectedCost !== undefined 
                                      ? edited.selectedCost 
                                      : result.selectedCost;
                                    const newSupplierName = edited.selectedSupplierName || result.selectedSupplierName || supplierName;
                                    
                                    if (!newCost || newCost <= 0) {
                                      setError('Please enter a valid cost');
                                      return;
                                    }
                                    
                                    if (!newSupplierName) {
                                      setError('Please enter a supplier name');
                                      return;
                                    }
                                    
                                    const cutoverId = currentCutoverId || extractionResult?.cutoverId || extractionSessionId;
                                    if (!cutoverId) {
                                      setError('Missing cutover ID');
                                      return;
                                    }
                                    
                                    try {
                                      // Re-approve with updated values
                                      const response = await fetch('/admin/inventory/cutover/approve-item', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                          cutoverId: cutoverId,
                                          productId: result.productId,
                                          cost: newCost,
                                          source: 'MANUAL_OVERRIDE',
                                          notes: `Supplier: ${newSupplierName}`,
                                          extractedEntries: result.extractedEntries || [],
                                          selectedSupplierId: edited.selectedSupplierId || result.selectedSupplierId,
                                          selectedSupplierName: newSupplierName,
                                        }),
                                      });
                                      
                                      if (!response.ok) {
                                        const data = await response.json();
                                        throw new Error(data.message || 'Failed to update approved item');
                                      }
                                      
                                      // Update local state
                                      setExtractionResults(prev => prev.map(r => 
                                        r.productId === result.productId ? { 
                                          ...r, 
                                          selectedCost: newCost,
                                          selectedSupplierName: newSupplierName,
                                          selectedSupplierId: edited.selectedSupplierId || result.selectedSupplierId,
                                        } : r
                                      ));
                                      
                                      // Refresh cost approvals to get updated notes
                                      const sessionResponse = await fetch(`/admin/inventory/cutover/extraction-session/${extractionSessionId}`);
                                      if (sessionResponse.ok) {
                                        const sessionData = await sessionResponse.json();
                                        if (sessionData.success && sessionData.session && sessionData.session.costApprovals) {
                                          const approvalsMap = {};
                                          sessionData.session.costApprovals
                                            .filter(approval => approval.productId === result.productId)
                                            .forEach(approval => {
                                              approvalsMap[approval.productId] = approval;
                                            });
                                          setCostApprovals(prev => ({ ...prev, ...approvalsMap }));
                                        }
                                      }
                                      
                                      setEditingApprovedItem(null);
                                    } catch (err) {
                                      setError(err.message || 'Failed to update approved item');
                                    }
                                  }}
                                  className="px-3 py-1 bg-green-600 hover:bg-green-700 text-white rounded text-sm"
                                >
                                  Save
                                </button>
                                <button
                                  onClick={() => {
                                    setEditingApprovedItem(null);
                                    // Revert changes
                                    setEditedResults(prev => {
                                      const newEdited = { ...prev };
                                      delete newEdited[result.productId];
                                      return newEdited;
                                    });
                                  }}
                                  className="px-3 py-1 border border-gray-300 rounded text-sm"
                                >
                                  Cancel
                                </button>
                              </>
                            ) : (
                              <button
                                onClick={() => setEditingApprovedItem(result.productId)}
                                className="px-3 py-1 border border-gray-300 rounded text-sm"
                              >
                                Edit
                              </button>
                            )}
                          </div>
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}

              {extractionTab === 'discarded' && (
                <div className="space-y-4">
                  {groupedResults.discarded.map(result => {
                    const isEditing = editingSkippedItem === result.productId;
                    const edited = editedResults[result.productId] || result;
                    
                    // Get supplier name from result
                    const supplierName = result.selectedSupplierName;
                    const currentCost = edited.selectedCost !== null && edited.selectedCost !== undefined 
                      ? edited.selectedCost 
                      : result.selectedCost || 0;
                    const currentSupplier = edited.selectedSupplierName || supplierName;
                    
                    return (
                      <div key={result.productId} className={`border border-gray-200 rounded-lg p-4 ${isEditing ? 'bg-white opacity-100' : 'bg-gray-50 opacity-60'}`}>
                        <div className="flex items-start gap-4">
                          {result.imageUrl && (
                            <img src={result.imageUrl} alt={result.productName} className={`w-20 h-20 object-cover rounded ${isEditing ? '' : 'grayscale'}`} />
                          )}
                          <div className="flex-1">
                            <h3 className="font-semibold text-gray-900">{result.productName}</h3>
                            <div className="mt-2 space-y-3">
                              <p className="text-sm text-gray-600">Status: <span className="text-red-600 font-medium">Discarded</span></p>
                              
                              {/* Cost - editable */}
                              <div>
                                <label className="text-xs text-gray-600 font-medium">Cost:</label>
                                {isEditing ? (
                                  <input
                                    type="number"
                                    step="0.01"
                                    min="0"
                                    value={currentCost || ''}
                                    onChange={(e) => {
                                      const newCost = parseFloat(e.target.value) || 0;
                                      setEditedResults(prev => {
                                        const newEdited = { ...prev };
                                        if (!newEdited[result.productId]) {
                                          newEdited[result.productId] = { ...result };
                                        }
                                        newEdited[result.productId].selectedCost = newCost;
                                        return newEdited;
                                      });
                                    }}
                                    className="mt-1 w-full px-2 py-1 border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-primary"
                                  />
                                ) : (
                                  <p className="text-sm text-gray-700 mt-1">
                                    {currentCost ? `$${typeof currentCost === 'number' ? currentCost.toFixed(2) : parseFloat(currentCost || 0).toFixed(2)}` : 'Not specified'}
                                  </p>
                                )}
                              </div>
                              
                              {/* Supplier - editable */}
                              <div>
                                <label className="text-xs text-gray-600 font-medium">Supplier:</label>
                                {isEditing ? (
                                  <div className="relative mt-1">
                                    <input
                                      type="text"
                                      value={edited.selectedSupplierName ?? currentSupplier ?? ''}
                                      onChange={(e) => {
                                        const newValue = e.target.value;
                                        setEditedResults(prev => {
                                          const newEdited = { ...prev };
                                          if (!newEdited[result.productId]) {
                                            newEdited[result.productId] = { ...result };
                                          }
                                          newEdited[result.productId].selectedSupplierName = newValue;
                                          return newEdited;
                                        });
                                        
                                        // Show autocomplete
                                        const localSuggestions = getSupplierSuggestions(newValue, '');
                                        if (localSuggestions.length > 0) {
                                          setOpenAutocomplete(prev => ({ ...prev, [`skipped_${result.productId}`]: true }));
                                          setSupplierSuggestions(prev => ({ ...prev, [`skipped_${result.productId}`]: localSuggestions }));
                                        } else if (newValue.length > 1) {
                                          fetch(`/admin/inventory/cutover/suppliers/suggest?q=${encodeURIComponent(newValue)}`)
                                            .then(res => res.json())
                                            .then(data => {
                                              if (data.success) {
                                                setOpenAutocomplete(prev => ({ ...prev, [`skipped_${result.productId}`]: true }));
                                                setSupplierSuggestions(prev => ({ ...prev, [`skipped_${result.productId}`]: data.suppliers }));
                                              }
                                            });
                                        } else {
                                          setOpenAutocomplete(prev => {
                                            const newState = { ...prev };
                                            delete newState[`skipped_${result.productId}`];
                                            return newState;
                                          });
                                        }
                                      }}
                                      onBlur={() => {
                                        setTimeout(() => {
                                          if (!dropdownSelectionRef.current[`skipped_${result.productId}`]) {
                                            setOpenAutocomplete(prev => {
                                              const newState = { ...prev };
                                              delete newState[`skipped_${result.productId}`];
                                              return newState;
                                            });
                                          }
                                          dropdownSelectionRef.current[`skipped_${result.productId}`] = false;
                                        }, 200);
                                      }}
                                      className="w-full px-2 py-1 border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-primary"
                                      placeholder="Enter supplier name"
                                    />
                                    {openAutocomplete[`skipped_${result.productId}`] && supplierSuggestions[`skipped_${result.productId}`] && supplierSuggestions[`skipped_${result.productId}`].length > 0 && (
                                      <div className="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg max-h-60 overflow-auto">
                                        {supplierSuggestions[`skipped_${result.productId}`].map((suggestion, sIdx) => (
                                          <div
                                            key={sIdx}
                                            className="px-3 py-2 hover:bg-gray-100 cursor-pointer text-sm"
                                            onMouseDown={() => {
                                              dropdownSelectionRef.current[`skipped_${result.productId}`] = true;
                                              setEditedResults(prev => {
                                                const newEdited = { ...prev };
                                                if (!newEdited[result.productId]) {
                                                  newEdited[result.productId] = { ...result };
                                                }
                                                newEdited[result.productId].selectedSupplierName = suggestion.name;
                                                newEdited[result.productId].selectedSupplierId = suggestion.id;
                                                return newEdited;
                                              });
                                              setOpenAutocomplete(prev => {
                                                const newState = { ...prev };
                                                delete newState[`skipped_${result.productId}`];
                                                return newState;
                                              });
                                            }}
                                          >
                                            <div className="font-medium">{suggestion.name}</div>
                                            {suggestion.contactInfo && (
                                              <div className="text-xs text-gray-500">{suggestion.contactInfo}</div>
                                            )}
                                          </div>
                                        ))}
                                      </div>
                                    )}
                                  </div>
                                ) : (
                                  <p className="text-sm text-gray-700 mt-1">
                                    {currentSupplier || 'Not specified'}
                                  </p>
                                )}
                              </div>
                            </div>
                          </div>
                          <div className="flex flex-col gap-2">
                            {isEditing ? (
                              <>
                                <button
                                  onClick={async () => {
                                    // Approve with edited values
                                    const edited = editedResults[result.productId] || result;
                                    const newCost = edited.selectedCost !== null && edited.selectedCost !== undefined 
                                      ? edited.selectedCost 
                                      : result.selectedCost || 0;
                                    const newSupplierName = edited.selectedSupplierName || result.selectedSupplierName || supplierName;
                                    
                                    if (!newCost || newCost <= 0) {
                                      setError('Please enter a valid cost');
                                      return;
                                    }
                                    
                                    if (!newSupplierName) {
                                      setError('Please enter a supplier name');
                                      return;
                                    }
                                    
                                    const cutoverId = currentCutoverId || extractionResult?.cutoverId || extractionSessionId;
                                    if (!cutoverId) {
                                      setError('Missing cutover ID');
                                      return;
                                    }
                                    
                                    try {
                                      // Approve the item with updated values
                                      const response = await fetch('/admin/inventory/cutover/approve-item', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                          cutoverId: cutoverId,
                                          productId: result.productId,
                                          cost: newCost,
                                          source: 'MANUAL_OVERRIDE',
                                          notes: `Supplier: ${newSupplierName}`,
                                          extractedEntries: result.extractedEntries || [],
                                          selectedSupplierId: edited.selectedSupplierId || result.selectedSupplierId,
                                          selectedSupplierName: newSupplierName,
                                        }),
                                      });
                                      
                                      if (!response.ok) {
                                        const data = await response.json();
                                        throw new Error(data.message || 'Failed to approve item');
                                      }
                                      
                                      // Update local state - move from discarded to approved
                                      setExtractionResults(prev => prev.map(r => 
                                        r.productId === result.productId ? { 
                                          ...r, 
                                          migrationStatus: 'APPROVED',
                                          selectedCost: newCost,
                                          selectedSupplierName: newSupplierName,
                                          selectedSupplierId: edited.selectedSupplierId || result.selectedSupplierId,
                                        } : r
                                      ));
                                      
                                      // Refresh cost approvals to get updated notes
                                      if (extractionSessionId) {
                                        const sessionResponse = await fetch(`/admin/inventory/cutover/extraction-session/${extractionSessionId}`);
                                        if (sessionResponse.ok) {
                                          const sessionData = await sessionResponse.json();
                                          if (sessionData.success && sessionData.session && sessionData.session.costApprovals) {
                                            const approvalsMap = {};
                                            sessionData.session.costApprovals
                                              .filter(approval => approval.productId === result.productId)
                                              .forEach(approval => {
                                                approvalsMap[approval.productId] = approval;
                                              });
                                            setCostApprovals(prev => ({ ...prev, ...approvalsMap }));
                                          }
                                        }
                                      }
                                      
                                      setEditingSkippedItem(null);
                                    } catch (err) {
                                      setError(err.message || 'Failed to approve item');
                                    }
                                  }}
                                  className="px-3 py-1 bg-green-600 hover:bg-green-700 text-white rounded text-sm"
                                >
                                  Approve
                                </button>
                                <button
                                  onClick={() => {
                                    setEditingSkippedItem(null);
                                    // Revert changes
                                    setEditedResults(prev => {
                                      const newEdited = { ...prev };
                                      delete newEdited[result.productId];
                                      return newEdited;
                                    });
                                  }}
                                  className="px-3 py-1 border border-gray-300 rounded text-sm"
                                >
                                  Cancel
                                </button>
                              </>
                            ) : (
                              <button
                                onClick={() => setEditingSkippedItem(result.productId)}
                                className="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm"
                              >
                                Edit
                              </button>
                            )}
                          </div>
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}
            </div>

            {/* Supplier Initials Learned Section */}
            {Object.keys(supplierInitialsMap).length > 0 && (
              <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
                <div className="flex items-center justify-between mb-2">
                  <h4 className="text-sm font-semibold text-blue-900">
                    Supplier Initials Learned ({Object.keys(supplierInitialsMap).length})
                  </h4>
                  <button
                    onClick={() => setSupplierInitialsMap({})}
                    className="text-xs text-blue-600 hover:text-blue-800 font-medium"
                  >
                    Clear All
                  </button>
                </div>
                <div className="space-y-2">
                  {Object.entries(supplierInitialsMap).map(([supplierName, initials]) => (
                    <div key={supplierName} className="flex items-center justify-between bg-white rounded p-2 border border-blue-100">
                      <div className="flex-1">
                        <span className="font-medium text-blue-900 text-sm">{supplierName}:</span>
                        <span className="text-blue-700 ml-2 text-sm">
                          {Array.isArray(initials) ? initials.join(', ') : initials}
                        </span>
                      </div>
                      <button
                        onClick={() => {
                          setSupplierInitialsMap(prev => {
                            const newMap = { ...prev };
                            delete newMap[supplierName];
                            return newMap;
                          });
                        }}
                        className="text-xs text-red-600 hover:text-red-800 ml-2"
                      >
                        Remove
                      </button>
                    </div>
                  ))}
                </div>
                <p className="text-xs text-blue-600 mt-2">
                  These will be saved when you approve items to help match suppliers in future extractions.
                </p>
              </div>
            )}

            {/* Batch Control */}
            {batchComplete && (
              <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                <div className="bg-white rounded-lg p-6 max-w-md">
                  <h3 className="text-lg font-bold mb-4">Batch Complete</h3>
                  <p className="text-sm text-gray-600 mb-4">
                    All items in this batch have been reviewed. Choose an action:
                  </p>
                  <div className="flex flex-col gap-3">
                    <button
                      onClick={handleContinueBatch}
                      disabled={loading}
                      className="w-full px-4 py-2 bg-primary hover:bg-primary-hover text-white rounded-md font-medium disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      {loading ? 'Loading...' : 'Continue to Next Batch'}
                    </button>
                    <button
                      onClick={() => {
                        setBatchComplete(false);
                        setState('reviewing');
                      }}
                      disabled={loading}
                      className="w-full px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-md font-medium disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      Review & Start Migration
                    </button>
                    <button
                      onClick={() => {
                        setBatchComplete(false);
                        setState('configuring');
                      }}
                      className="w-full px-4 py-2 border border-gray-300 hover:bg-gray-50 rounded-md"
                    >
                      Pause & Exit
                    </button>
                  </div>
                </div>
              </div>
            )}

            {/* Final Review Button */}
            {state === 'reviewing' && (
              <div className="flex justify-end">
                <button
                  onClick={handleStartMigration}
                  disabled={loading}
                  className="px-6 py-2 bg-green-600 text-white rounded-md font-medium disabled:opacity-50"
                >
                  {loading ? 'Starting Migration...' : 'Start Migration'}
                </button>
              </div>
            )}
          </div>
        );
      }

      // Phase 3: Migration Execution
      if (state === 'migrating') {
        return (
          <div className="max-w-4xl mx-auto space-y-6">
            <h2 className="text-2xl font-bold text-gray-900">Migration Execution</h2>
            
            <div className="bg-gray-50 rounded-lg p-6 text-center">
              <div className="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-primary mb-4"></div>
              <p className="text-gray-700 font-medium">Processing migration...</p>
              {migrationResult && (
                <div className="mt-4 text-sm text-gray-600">
                  <p>Batch: {migrationResult.currentBatch} / {migrationResult.totalBatches}</p>
                  <p>Processed: {migrationResult.processedItems} / {migrationResult.totalItems}</p>
                  {migrationResult.skippedItems > 0 && (
                    <p className="text-yellow-600">Skipped: {migrationResult.skippedItems} items</p>
                  )}
                </div>
              )}
            </div>
          </div>
        );
      }

      // Phase 4: Report
      if (state === 'reporting' && reportData) {
        const exportToCSV = () => {
          if (!reportData.errors || reportData.errors.length === 0) return;
          const csv = [
            ['Product', 'Error Message', 'Recommendation'],
            ...reportData.errors.map(err => [
              err.productName || err.productId || '',
              err.message || '',
              err.recommendation || ''
            ])
          ].map(row => row.map(cell => `"${cell}"`).join(',')).join('\\n');
          const blob = new Blob([csv], { type: 'text/csv' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'migration-errors.csv';
          a.click();
        };

        return (
          <div className="max-w-4xl mx-auto space-y-6">
            <div className="bg-green-50 border border-green-200 rounded-lg p-6">
              <h2 className="text-2xl font-bold text-green-800 mb-2">Migration Complete</h2>
              <div className="grid grid-cols-3 gap-4 mt-4">
                <div>
                  <div className="text-2xl font-bold text-green-700">{reportData.productsProcessed || 0}</div>
                  <div className="text-sm text-green-600">Items Migrated</div>
                </div>
                <div>
                  <div className="text-2xl font-bold text-red-700">{reportData.errors?.length || 0}</div>
                  <div className="text-sm text-red-600">Errors</div>
                </div>
                <div>
                  <div className="text-2xl font-bold text-yellow-700">{reportData.skippedItems || 0}</div>
                  <div className="text-sm text-yellow-600">Skipped</div>
                </div>
              </div>
            </div>

            {reportData.errors && reportData.errors.length > 0 && (
              <div>
                <div className="flex justify-between items-center mb-4">
                  <h3 className="text-lg font-semibold">Error List</h3>
                  <button
                    onClick={exportToCSV}
                    className="px-4 py-2 bg-gray-600 text-white rounded-md text-sm"
                  >
                    Download Error Report CSV
                  </button>
                </div>
                <table className="min-w-full divide-y divide-gray-200">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Product</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Error Message</th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Recommendation</th>
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {reportData.errors.map((err, idx) => (
                      <tr key={idx}>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                          {err.productName || err.productId || '‚Äî'}
                        </td>
                        <td className="px-6 py-4 text-sm text-gray-600">{err.message || '‚Äî'}</td>
                        <td className="px-6 py-4 text-sm text-gray-600">{err.recommendation || '‚Äî'}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </div>
        );
      }

      return (
        <div className="max-w-4xl mx-auto space-y-6">
          <h2 className="text-2xl font-bold text-gray-900">Inventory Migration</h2>
          <p className="text-gray-600">Please configure the migration to begin.</p>

          {error && (
            <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg">
              {error}
            </div>
          )}

          {/* Tab Navigation */}
          {step === 'extract' && (
            <div className="flex gap-2 mb-6 border-b-2 border-gray-200">
              <button 
                className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors ${
                  migrationSectionTab === 'configuration' 
                    ? 'border-primary text-primary font-semibold' 
                    : 'border-transparent text-gray-600 hover:text-primary'
                }`}
                onClick={() => setMigrationSectionTab('configuration')}
              >
                Configuration
              </button>
              <button 
                className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors relative ${
                  migrationSectionTab === 'cost-extraction' 
                    ? 'border-primary text-primary font-semibold' 
                    : 'border-transparent text-gray-600 hover:text-primary'
                } ${costBasis === 'DESCRIPTION' ? '' : 'opacity-60'}`}
                onClick={() => setMigrationSectionTab('cost-extraction')}
                title={costBasis !== 'DESCRIPTION' ? 'Cost extraction is only required for "Extract from Description" cost basis' : ''}
              >
                Cost Extraction
                {costBasis === 'DESCRIPTION' && (
                  <span className="ml-2 text-xs font-semibold bg-red-100 text-red-600 px-2 py-0.5 rounded-full">
                    Required
                  </span>
                )}
              </button>
              <button 
                className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors ${
                  migrationSectionTab === 'migration' 
                    ? 'border-primary text-primary font-semibold' 
                    : 'border-transparent text-gray-600 hover:text-primary'
                }`}
                onClick={() => setMigrationSectionTab('migration')}
              >
                Migration
              </button>
            </div>
          )}

          {/* Configuration Tab */}
          {step === 'extract' && migrationSectionTab === 'configuration' && (
            <div className="space-y-6">
              <div className="space-y-1">
                <label className="block text-sm font-medium text-gray-700">Cutover Date</label>
                <input
                  type="date"
                  value={cutoverDate}
                  onChange={(e) => setCutoverDate(e.target.value)}
                  className="block w-full rounded-md border-gray-300 shadow-sm focus:border-primary focus:ring-primary sm:text-sm"
                />
                <p className="text-xs text-gray-500 mt-1">
                  The date when the new system becomes the system of record.
                </p>
              </div>

              <div className="space-y-1">
                <div className="flex justify-between items-center mb-2">
                  <label className="block text-sm font-medium text-gray-700">Target Locations</label>
                  <button 
                    onClick={fetchLocations} 
                    disabled={loadingLocations}
                    className="px-3 py-1.5 bg-gray-600 hover:bg-gray-700 text-white text-xs font-medium rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    {loadingLocations ? 'Loading...' : 'Refresh List'}
                  </button>
                </div>
                {locations.length === 0 ? (
                  <div className="p-4 bg-gray-50 rounded-lg text-gray-600 text-center border border-gray-200">
                    No locations found. Use the Locations module to sync locations from Square.
                  </div>
                ) : (
                  <div className="flex flex-col gap-2 p-3 border border-gray-200 rounded-lg bg-white">
                    {locations.map(loc => (
                      <label key={loc.id} className="flex items-center p-2 hover:bg-gray-50 rounded cursor-pointer">
                        <input
                          type="radio"
                          name="location"
                          value={loc.id}
                          checked={selectedLocation === loc.id}
                          onChange={(e) => setSelectedLocation(e.target.value)}
                          className="text-primary border-gray-300 focus:ring-primary"
                        />
                        <span className="ml-2 text-sm text-gray-700">
                          {loc.name} {loc.squareId && <span className="text-gray-500">({loc.squareId})</span>}
                        </span>
                      </label>
                    ))}
                  </div>
                )}
              </div>

              <div className="space-y-1">
                <label className="block text-sm font-medium text-gray-700">Cost Basis</label>
                <select
                  value={costBasis}
                  onChange={(e) => {
                    setCostBasis(e.target.value);
                    // Auto-switch to cost extraction tab if DESCRIPTION is selected
                    if (e.target.value === 'DESCRIPTION') {
                      setMigrationSectionTab('cost-extraction');
                    }
                  }}
                  className="block w-full rounded-md border-gray-300 shadow-sm focus:border-primary focus:ring-primary sm:text-sm"
                >
                  <option value="DESCRIPTION">$ Extract from Description</option>
                  <option value="SQUARE_COST">Square Cost</option>
                  <option value="MANUAL_INPUT">Manual Input</option>
                  <option value="AVERAGE_COST">Average Cost</option>
                </select>
                <p className="text-xs text-gray-500 mt-1">
                  Method used to determine the initial cost of inventory items.
                </p>
                {costBasis === 'DESCRIPTION' && (
                  <p className="text-xs text-red-600 mt-1 font-medium">
                    ‚ö†Ô∏è Cost extraction is required for this cost basis. Please complete the Cost Extraction step before proceeding.
                  </p>
                )}
              </div>

              <div className="space-y-4">
                <h3 className="text-sm font-semibold text-gray-900">Processing Settings</h3>
                
                <div className="space-y-1">
                  <label className="block text-sm font-medium text-gray-700">Migration Batch Size (items per batch)</label>
                  <input
                    type="number"
                    value={batchSize || ''}
                    onChange={(e) => {
                      const value = e.target.value;
                      setBatchSize(value === '' ? '' : (parseInt(value) || ''));
                    }}
                    placeholder="100"
                    min="1"
                    className="block w-full rounded-md border-gray-300 shadow-sm focus:border-primary focus:ring-primary sm:text-sm"
                  />
                  <p className="text-xs text-gray-500 mt-1">
                    Process migration in batches to avoid server timeouts. Leave empty for all at once.
                  </p>
                </div>

                {costBasis === 'DESCRIPTION' && (
                  <div className="space-y-1">
                    <label className="block text-sm font-medium text-gray-700">Cost Extraction Batch Size (items per batch)</label>
                    <input
                      type="number"
                      value={extractionBatchSize || ''}
                      onChange={(e) => {
                        const value = e.target.value;
                        setExtractionBatchSize(value === '' ? '' : (parseInt(value) || ''));
                      }}
                      placeholder="100"
                      min="1"
                      className="block w-full rounded-md border-gray-300 shadow-sm focus:border-primary focus:ring-primary sm:text-sm"
                    />
                    <p className="text-xs text-gray-500 mt-1">
                      Required for 'Extract from Description'. Processes products to extract embedded costs.
                    </p>
                  </div>
                )}
              </div>

              {/* Warning Banner */}
              <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4 flex items-start gap-3">
                <span className="text-yellow-600 text-xl">‚ö†Ô∏è</span>
                <p className="text-sm text-yellow-800">
                  System will be locked for editing during the migration process.
                </p>
              </div>
            </div>
          )}

          {/* Cost Extraction Tab */}
          {step === 'extract' && migrationSectionTab === 'cost-extraction' && (
            <div className="space-y-6">
              {costBasis === 'DESCRIPTION' ? (
                <div className="space-y-4">
                  <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 flex items-start gap-3">
                    <span className="text-blue-600 text-xl">‚ÑπÔ∏è</span>
                    <div>
                      <h3 className="font-semibold text-blue-800 mb-1">Cost Extraction Required</h3>
                      <p className="text-sm text-blue-700">
                        Cost extraction is required for "Extract from Description" cost basis.
                        This will process all products to extract costs from their descriptions.
                        You must complete this step before proceeding to migration.
                      </p>
                    </div>
                  </div>
                  
                  {extractionResult && (
                    <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                      <h4 className="font-semibold text-yellow-800 mb-2">Extraction Batch Progress</h4>
                      <p className="text-sm text-yellow-700 mb-1">
                        <strong>Batch:</strong> {extractionResult.currentBatch} / {extractionResult.totalBatches}
                        {currentBatchId && (
                          <span className="ml-2 text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded">
                            Batch ID: {currentBatchId.substring(0, 8)}...
                          </span>
                        )}
                      </p>
                      <p className="text-sm text-yellow-700 mb-3"><strong>Processed:</strong> {extractionResult.processedItems} / {extractionResult.totalItems} items</p>
                      <div className="bg-gray-200 rounded-full h-2 overflow-hidden">
                        <div 
                          className="bg-primary h-full transition-all duration-300"
                          style={{ width: `${(extractionResult.processedItems / extractionResult.totalItems) * 100}%` }}
                        ></div>
                      </div>
                      <p className="text-sm text-yellow-700 mt-3">
                        Products Extracted: {extractionResult.productsWithExtraction} | 
                        Requiring Manual Input: {extractionResult.productsRequiringManualInput}
                      </p>
                      {extractionApproved && manualInputApproved && currentBatchId && (
                        <div className="mt-3 pt-3 border-t border-yellow-300">
                          <p className="text-sm font-medium text-green-700">
                            ‚úì Batch approval ready - Both checkboxes checked
                          </p>
                        </div>
                      )}
                    </div>
                  )}

                  <div className="flex gap-3 flex-wrap">
                    {!extractionResult && (
                      <button 
                        onClick={() => handleExtractCosts(false)} 
                        disabled={loading || !selectedLocation}
                        className="px-4 py-2 bg-primary hover:bg-primary-hover text-white rounded-md text-sm font-medium shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary disabled:opacity-50 disabled:cursor-not-allowed"
                      >
                        {loading ? 'Extracting Costs...' : 'Extract Costs from Descriptions'}
                      </button>
                    )}
                    {extractionResult && !extractionResult.isComplete && (
                      <>
                        <button 
                          onClick={() => handleExtractCosts(true)} 
                          disabled={loading}
                          className="px-4 py-2 bg-primary hover:bg-primary-hover text-white rounded-md text-sm font-medium shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                          {loading ? 'Processing Batch...' : `Continue Extraction Batch ${extractionResult.currentBatch + 1}/${extractionResult.totalBatches}`}
                        </button>
                        <button 
                          onClick={() => setStep('approve')} 
                          disabled={loading}
                          className="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-md text-sm font-medium shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                          Review Extracted Costs ({extractionResult.processedItems} items)
                        </button>
                      </>
                    )}
                    {extractionResult && extractionResult.isComplete && (
                      <button 
                        onClick={() => setStep('approve')} 
                        disabled={loading}
                        className="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-md text-sm font-medium shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 disabled:opacity-50 disabled:cursor-not-allowed"
                      >
                        Review & Approve Extracted Costs
                      </button>
                    )}
                  </div>
                </div>
              ) : (
                <div className="space-y-4">
                  <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
                    <p className="text-gray-600">
                      Cost extraction is not required for "{costBasis}" cost basis.
                      You can proceed directly to migration.
                    </p>
                  </div>
                  <button 
                    onClick={() => {
                      setMigrationSectionTab('migration');
                      setStep('migrate');
                      setApprovedCosts({});
                    }} 
                    disabled={loading || !selectedLocation}
                    className="px-4 py-2 bg-primary hover:bg-primary-hover text-white rounded-md text-sm font-medium shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    Proceed to Migration
                  </button>
                </div>
              )}
            </div>
          )}

          {/* Migration Tab */}
          {step === 'extract' && migrationSectionTab === 'migration' && (
            <div className="space-y-6">
              {costBasis === 'DESCRIPTION' && !extractionResult && (
                <div className="bg-red-50 border border-red-200 rounded-lg p-4 flex items-start gap-3">
                  <span className="text-red-600 text-xl">‚ö†Ô∏è</span>
                  <div>
                    <h3 className="font-semibold text-red-800 mb-1">Cost Extraction Required</h3>
                    <p className="text-sm text-red-700">
                      You must complete the Cost Extraction step before proceeding with migration.
                      Please go to the "Cost Extraction" tab and extract costs first.
                    </p>
                  </div>
                </div>
              )}
              {costBasis === 'DESCRIPTION' && extractionResult && (
                <div className="bg-green-50 border border-green-200 rounded-lg p-4 flex items-start gap-3">
                  <span className="text-green-600 text-xl">‚úì</span>
                  <div>
                    <h3 className="font-semibold text-green-800 mb-1">Cost Extraction Complete</h3>
                    <p className="text-sm text-green-700">
                      Cost extraction has been completed. You can now proceed with the migration.
                    </p>
                  </div>
                </div>
              )}
              <div className="flex justify-end gap-3 pt-4">
                <button
                  onClick={() => {
                    setSelectedLocation(null);
                    setCutoverDate(new Date().toISOString().split('T')[0]);
                    setCostBasis('DESCRIPTION');
                    setBatchSize(100);
                    setExtractionBatchSize(100);
                    setExtractionResult(null);
                    setError(null);
                    setMigrationSectionTab('configuration');
                  }}
                  className="px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-700 rounded-md text-sm font-medium shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500"
                >
                  Cancel
                </button>
                <button
                  onClick={() => {
                    if (costBasis === 'DESCRIPTION' && !extractionResult) {
                      setError('Please complete cost extraction before proceeding with migration.');
                      setMigrationSectionTab('cost-extraction');
                      return;
                    }
                    setStep('migrate');
                    setApprovedCosts({});
                  }}
                  disabled={loading || !selectedLocation || (costBasis === 'DESCRIPTION' && !extractionResult)}
                  className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md text-sm font-medium shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                >
                  <span>‚ñ∫</span> Start Migration
                </button>
              </div>
            </div>
          )}

          {step === 'approve' && extractionResult && (
            <div className="max-w-5xl mx-auto space-y-8">
              <div>
                <h1 className="text-3xl font-bold text-gray-900 mb-6">Review Extracted Costs</h1>
                
                {!extractionResult.isComplete && (
                  <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-5 flex flex-col md:flex-row items-start md:items-center justify-between gap-4 shadow-sm mb-6">
                    <div className="flex gap-4">
                      <div className="flex-shrink-0">
                        <span className="material-icons text-yellow-600 text-3xl">warning</span>
                      </div>
                      <div>
                        <h3 className="text-lg font-semibold text-yellow-800">Extraction Incomplete</h3>
                        <p className="text-yellow-700 mt-1 max-w-2xl text-sm leading-relaxed">
                          Only <span className="font-bold">{extractionResult.processedItems} of {extractionResult.totalItems}</span> items have been extracted. You can review and approve the extracted costs now, or continue extraction to process remaining items.
                        </p>
                      </div>
                    </div>
                    <button 
                      onClick={() => {
                        setStep('extract');
                        handleExtractCosts(true);
                      }}
                      disabled={loading}
                      className="bg-primary hover:bg-primary-hover text-white px-5 py-2.5 rounded-lg font-medium shadow-sm transition-all focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 text-sm whitespace-nowrap disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      Continue Extraction
                    </button>
                  </div>
                )}

                {/* Batch Approval Checkboxes */}
                {currentBatchId && (
                  <div className="bg-white border border-gray-200 rounded-lg p-6 mb-6 shadow-sm">
                    <h3 className="text-lg font-semibold text-gray-900 mb-4">Batch Approval</h3>
                    <div className="space-y-4">
                      <div className="flex items-start gap-3">
                        <input
                          type="checkbox"
                          id="extractionApproved"
                          checked={extractionApproved}
                          onChange={(e) => setExtractionApproved(e.target.checked)}
                          className="mt-1 h-5 w-5 text-primary focus:ring-primary border-gray-300 rounded"
                        />
                        <label htmlFor="extractionApproved" className="flex-1 cursor-pointer">
                          <span className="font-medium text-gray-900">Approve Extracted Items</span>
                          <p className="text-sm text-gray-600 mt-1">
                            Approve all items with extracted costs ({extractionResult.productsWithExtraction} products)
                          </p>
                        </label>
                      </div>
                      <div className="flex items-start gap-3">
                        <input
                          type="checkbox"
                          id="manualInputApproved"
                          checked={manualInputApproved}
                          onChange={(e) => setManualInputApproved(e.target.checked)}
                          className="mt-1 h-5 w-5 text-primary focus:ring-primary border-gray-300 rounded"
                        />
                        <label htmlFor="manualInputApproved" className="flex-1 cursor-pointer">
                          <span className="font-medium text-gray-900">Approve Manual Input Items</span>
                          <p className="text-sm text-gray-600 mt-1">
                            Approve all items requiring manual input ({extractionResult.productsRequiringManualInput} products)
                          </p>
                        </label>
                      </div>
                      {extractionApproved && manualInputApproved && (
                        <div className="bg-green-50 border border-green-200 rounded-lg p-3 mt-4">
                          <p className="text-sm text-green-800">
                            ‚úì Both approval checkboxes are checked. You can now approve the batch and continue.
                          </p>
                        </div>
                      )}
                    </div>
                  </div>
                )}

                {/* Supplier Initials Management */}
                {Object.keys(supplierInitialsMap).length > 0 && (
                  <div className="bg-white border border-gray-200 rounded-lg p-6 mb-6 shadow-sm">
                    <h3 className="text-lg font-semibold text-gray-900 mb-4">Supplier Initials Management</h3>
                    <p className="text-sm text-gray-600 mb-4">
                      These initials will be used to infer supplier names in future extraction batches.
                    </p>
                    <div className="space-y-3">
                      {Object.entries(supplierInitialsMap).map(([supplierName, initials]) => (
                        <div key={supplierName} className="border border-gray-200 rounded-lg p-4">
                          <div className="flex items-center justify-between mb-2">
                            <span className="font-medium text-gray-900">{supplierName}</span>
                            <button
                              onClick={() => {
                                const initial = prompt(`Enter a new initial for "${supplierName}":`);
                                if (initial && initial.trim()) {
                                  setSupplierInitialsMap(prev => {
                                    const current = prev[supplierName] || [];
                                    if (!current.includes(initial.trim())) {
                                      return {
                                        ...prev,
                                        [supplierName]: [...current, initial.trim()]
                                      };
                                    }
                                    return prev;
                                  });
                                }
                              }}
                              className="text-xs px-2 py-1 bg-primary text-white rounded hover:bg-primary-hover"
                            >
                              + Add Initial
                            </button>
                          </div>
                          <div className="flex flex-wrap gap-2 mt-2">
                            {Array.isArray(initials) ? initials.map((initial, idx) => (
                              <span
                                key={idx}
                                className="inline-flex items-center gap-1 px-2 py-1 bg-gray-100 text-gray-700 rounded text-sm"
                              >
                                {initial}
                                <button
                                  onClick={() => {
                                    setSupplierInitialsMap(prev => {
                                      const current = prev[supplierName] || [];
                                      return {
                                        ...prev,
                                        [supplierName]: current.filter((_, i) => i !== idx)
                                      };
                                    });
                                  }}
                                  className="text-gray-500 hover:text-red-600"
                                >
                                  √ó
                                </button>
                              </span>
                            )) : (
                              <span className="text-sm text-gray-500">No initials yet</span>
                            )}
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {/* Tab Navigation */}
                <div className="flex gap-4 mb-6 border-b border-gray-200">
                  <button
                    onClick={() => setActiveTab('EXTRACTED')}
                    className={`px-6 py-3 font-medium text-sm transition-colors border-b-2 ${
                      activeTab === 'EXTRACTED'
                        ? 'border-purple-600 text-purple-600'
                        : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                    }`}
                  >
                    Approved
                    <span className="ml-2 text-xs font-semibold bg-gray-100 text-gray-600 px-2 py-0.5 rounded-full">
                      {extractionResult.extractionResults.filter(r => r.isAlreadyApproved).length}
                    </span>
                  </button>
                  <button
                    onClick={() => setActiveTab('WITH_EXTRACTION')}
                    className={`px-6 py-3 font-medium text-sm transition-colors border-b-2 ${
                      activeTab === 'WITH_EXTRACTION'
                        ? 'border-green-600 text-green-600'
                        : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                    }`}
                  >
                    With Extraction
                    <span className="ml-2 text-xs font-semibold bg-gray-100 text-gray-600 px-2 py-0.5 rounded-full">
                      {extractionResult.extractionResults.filter(r => (r.extractedEntries || []).length > 0 && !r.isAlreadyApproved).length}
                    </span>
                  </button>
                  <button
                    onClick={() => setActiveTab('MANUAL_INPUT')}
                    className={`px-6 py-3 font-medium text-sm transition-colors border-b-2 ${
                      activeTab === 'MANUAL_INPUT'
                        ? 'border-orange-600 text-orange-600'
                        : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                    }`}
                  >
                    Manual Input
                    <span className="ml-2 text-xs font-semibold bg-gray-100 text-gray-600 px-2 py-0.5 rounded-full">
                      {extractionResult.productsRequiringManualInput}
                    </span>
                  </button>
                  <button
                    onClick={() => setActiveTab('TOTAL_PRODUCTS')}
                    className={`px-6 py-3 font-medium text-sm transition-colors border-b-2 ${
                      activeTab === 'TOTAL_PRODUCTS'
                        ? 'border-blue-600 text-blue-600'
                        : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                    }`}
                  >
                    Total Products
                    <span className="ml-2 text-xs font-semibold bg-gray-100 text-gray-600 px-2 py-0.5 rounded-full">
                      {extractionResult.totalProducts}
                    </span>
                  </button>
                  <button
                    disabled
                    className="px-6 py-3 font-medium text-sm text-gray-400 border-b-2 border-transparent cursor-not-allowed opacity-50"
                  >
                    Remaining
                    <span className="ml-2 text-xs font-semibold bg-gray-100 text-gray-400 px-2 py-0.5 rounded-full">
                      {!extractionResult.isComplete ? extractionResult.totalItems - extractionResult.processedItems : 0}
                    </span>
                  </button>
                </div>
              </div>
              
              <div className="space-y-6 max-h-[600px] overflow-y-auto">
                {extractionResult.extractionResults.filter(result => {
                  // Filter based on active tab
                  if (activeTab === 'EXTRACTED') {
                    // Show only approved items
                    return result.isAlreadyApproved === true;
                  } else if (activeTab === 'WITH_EXTRACTION') {
                    // Show only new items with extraction (excluding already-approved)
                    return (result.extractedEntries || []).length > 0 && !result.isAlreadyApproved;
                  } else if (activeTab === 'MANUAL_INPUT') {
                    // Show only items requiring manual input (no extraction, not already approved)
                    return (result.extractedEntries || []).length === 0 && !result.isAlreadyApproved;
                  } else if (activeTab === 'TOTAL_PRODUCTS') {
                    // Show all items (both extracted and manual input, including already-approved)
                    return true;
                  }
                  return false;
                }).map(result => {
                  const editedResult = editedResults[result.productId] || result;
                  
                  // Handle already-approved products with minimal UI
                  if (result.isAlreadyApproved) {
                    const approvalDate = result.existingApprovalDate 
                      ? new Date(result.existingApprovalDate).toLocaleDateString('en-US', { 
                          year: 'numeric', 
                          month: 'short', 
                          day: 'numeric' 
                        })
                      : 'Unknown date';
                    
                    // Safely convert approved cost to number
                    let approvedCostNum = 0;
                    if (result.existingApprovedCost) {
                      if (typeof result.existingApprovedCost === 'object' && result.existingApprovedCost.toNumber) {
                        approvedCostNum = result.existingApprovedCost.toNumber();
                      } else if (typeof result.existingApprovedCost === 'number') {
                        approvedCostNum = result.existingApprovedCost;
                      } else if (typeof result.existingApprovedCost === 'string') {
                        approvedCostNum = parseFloat(result.existingApprovedCost) || 0;
                      }
                    } else if (result.selectedCost !== null && result.selectedCost !== undefined) {
                      approvedCostNum = typeof result.selectedCost === 'number' ? result.selectedCost : parseFloat(result.selectedCost) || 0;
                    }
                    
                    return (
                      <div key={result.productId} className="bg-gray-50 rounded-xl border border-gray-300 shadow-sm overflow-hidden opacity-75">
                        <div className="p-6">
                          <div className="flex items-start justify-between mb-4">
                            <div className="flex-1">
                              <h3 className="text-lg font-semibold text-gray-700">{result.productName}</h3>
                              <div className="mt-2 flex items-center gap-3">
                                <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                                  ‚úì Already Approved
                                </span>
                                <span className="text-sm text-gray-500">
                                  Approved on {approvalDate}
                                </span>
                              </div>
                            </div>
                            <div className="text-right">
                              <div className="text-sm text-gray-500">Approved Cost</div>
                              <div className="text-xl font-bold text-gray-700">
                                ${approvedCostNum.toFixed(2)}
                              </div>
                            </div>
                          </div>
                          {result.existingCutoverId && (
                            <div className="text-xs text-gray-400 mt-2">
                              Cutover ID: {result.existingCutoverId}
                            </div>
                          )}
                        </div>
                      </div>
                    );
                  }
                  // Find the selected entry (the one with isSelected = true)
                  const selectedEntry = editedResult.extractedEntries.find(e => e.isSelected) 
                    || (editedResult.extractedEntries.length > 0 ? editedResult.extractedEntries[editedResult.extractedEntries.length - 1] : null);
                  const selectedSupplierId = editedResult.selectedSupplierId || selectedEntry?.supplierId || null;
                  const selectedSupplierName = editedResult.selectedSupplierName || selectedEntry?.supplier || 'General';
                  const selectedCost = editedResult.selectedCost || result.selectedCost || null;
                  
                  // Extract unique suppliers from extracted entries for dropdown
                  const uniqueSuppliers = [...new Set(
                    editedResult.extractedEntries.map(e => 
                      (e.editedSupplierName !== undefined && e.editedSupplierName !== null) 
                        ? e.editedSupplierName 
                        : (e.supplier || 'General')
                    )
                  )];
                  
                  // Preferred supplier: default to selected option's supplier, but allow independent selection
                  const preferredSupplierName = editedResult.preferredSupplierName !== undefined 
                    ? editedResult.preferredSupplierName 
                    : selectedSupplierName;
                  
                  // Get date from selected entry (user input from selected option)
                  let selectedDate = null;
                  if (selectedEntry) {
                    selectedDate = selectedEntry.editedEffectiveDate || null;
                    // If no edited date, calculate default from extracted month or one week ago
                    if (!selectedDate && selectedEntry.month) {
                      const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                      const monthIndex = monthNames.indexOf(selectedEntry.month);
                      if (monthIndex !== -1) {
                        const now = new Date();
                        const currentYear = now.getFullYear();
                        const currentMonth = now.getMonth();
                        const year = monthIndex > currentMonth ? currentYear - 1 : currentYear;
                        const extractedDate = new Date(year, monthIndex, 1);
                        selectedDate = extractedDate.toISOString().split('T')[0];
                      }
                    }
                    if (!selectedDate) {
                      // Default: one week ago
                      const defaultDate = new Date();
                      defaultDate.setDate(defaultDate.getDate() - 7);
                      selectedDate = defaultDate.toISOString().split('T')[0];
                    }
                  }
                  
                  // Split product name into main name and brand (last 1-2 words as brand)
                  const splitProductName = (name) => {
                    if (!name) return { main: '', brand: '' };
                    const words = name.trim().split(/\s+/);
                    if (words.length <= 1) return { main: name, brand: '' };
                    // If 2-3 words, use last word as brand
                    if (words.length <= 3) {
                      return { main: words.slice(0, -1).join(' '), brand: words[words.length - 1] };
                    }
                    // For longer names, use last 2 words as brand
                    return { main: words.slice(0, -2).join(' '), brand: words.slice(-2).join(' ') };
                  };
                  const { main: productMainName, brand: productBrand } = splitProductName(result.productName);

                  return (
                    <div key={result.productId} className="bg-white rounded-xl border border-gray-200 shadow-sm overflow-hidden">
                      {editedResult.extractedEntries.length > 0 ? (
                        <div className="p-6 grid grid-cols-1 lg:grid-cols-12 gap-8">
                          <div className="lg:col-span-4 space-y-5">
                            {/* Product Image */}
                            <div className="w-full bg-gray-200 rounded-lg flex items-center justify-center relative" style={{ height: '200px', minHeight: '200px' }}>
                              {result.imageUrl ? (
                                <>
                                  <img 
                                    src={result.imageUrl} 
                                    alt={result.productName}
                                    className="w-full h-full object-cover rounded-lg"
                                    onError={(e) => {
                                      // Hide image and show placeholder if image fails to load
                                      e.target.style.display = 'none';
                                      const placeholder = e.target.parentElement?.querySelector('.image-placeholder');
                                      if (placeholder) {
                                        placeholder.style.display = 'flex';
                                      }
                                    }}
                                  />
                                  <div className="image-placeholder absolute inset-0 w-full h-full bg-gray-200 rounded-lg flex items-center justify-center" style={{ display: 'none' }}>
                                    <div className="text-center">
                                      <span className="material-icons text-gray-400 text-6xl">image</span>
                                      <p className="text-xs text-gray-500 mt-2">No Product Image</p>
                                    </div>
                                  </div>
                                </>
                              ) : (
                                <div className="text-center">
                                  <span className="material-icons text-gray-400 text-6xl">image</span>
                                  <p className="text-xs text-gray-500 mt-2">No Product Image</p>
                                </div>
                              )}
                            </div>
                            
                            {/* Product Name - Two Lines */}
                            <div>
                              <h2 className="text-xl font-bold text-gray-900">{productMainName}</h2>
                              {productBrand && <p className="text-xl font-bold text-gray-900">{productBrand}</p>}
                            </div>
                            
                            {/* Separator instead of "SELECTED VALUES" heading */}
                            <div className="border-t border-gray-200 my-4"></div>
                            <div className="space-y-1">
                              <label className="block text-xs font-medium text-gray-500 uppercase">Supplier Name</label>
                              <input 
                                className="block w-full rounded-md border-gray-300 bg-gray-50 text-gray-900 shadow-sm focus:border-primary focus:ring-primary sm:text-sm" 
                                readOnly 
                                type="text" 
                                value={selectedSupplierName || 'N/A'}
                              />
                            </div>
                            <div className="space-y-1">
                              <label className="block text-xs font-medium text-gray-500 uppercase">Cost</label>
                              <div className="relative rounded-md shadow-sm">
                                <div className="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3">
                                  <span className="text-gray-500 sm:text-sm">$</span>
                                </div>
                                <input 
                                  className="block w-full rounded-md border-gray-300 bg-gray-50 text-gray-900 shadow-sm focus:border-primary focus:ring-primary sm:text-sm" 
                                  style={{ paddingLeft: '21px' }}
                                  readOnly 
                                  type="text" 
                                  value={selectedCost !== null && selectedCost !== undefined ? selectedCost.toFixed(2) : 'N/A'}
                                />
                              </div>
                            </div>
                            <div className="space-y-1">
                              <label className="block text-xs font-medium text-gray-500 uppercase">Preferred Supplier</label>
                              <select
                                className="block w-full rounded-md border-gray-300 bg-white text-gray-900 shadow-sm focus:border-primary focus:ring-primary sm:text-sm"
                                value={preferredSupplierName || 'General'}
                                onChange={(e) => {
                                  const newResults = { ...editedResults };
                                  if (!newResults[result.productId]) {
                                    newResults[result.productId] = { ...result };
                                  }
                                  newResults[result.productId].preferredSupplierName = e.target.value;
                                  setEditedExtractionResults(newResults);
                                }}
                              >
                                {uniqueSuppliers.map((supplier, idx) => (
                                  <option key={idx} value={supplier}>{supplier}</option>
                                ))}
                              </select>
                            </div>
                            <div className="space-y-1">
                              <label className="block text-xs font-medium text-gray-500 uppercase">Cost History Date</label>
                              <input 
                                className="block w-full rounded-md border-gray-300 bg-gray-50 text-gray-900 shadow-sm focus:border-primary focus:ring-primary sm:text-sm" 
                                readOnly 
                                type="text" 
                                value={selectedDate ? (() => {
                                  // Parse date string (format: YYYY-MM-DD or MM/DD/YYYY)
                                  // Always parse as local time to avoid timezone issues
                                  let date;
                                  if (selectedDate.includes('/')) {
                                    // Handle MM/DD/YYYY format
                                    const parts = selectedDate.split('/');
                                    const month = parseInt(parts[0], 10) - 1; // JavaScript months are 0-indexed
                                    const day = parseInt(parts[1], 10);
                                    const year = parseInt(parts[2], 10);
                                    date = new Date(year, month, day);
                                  } else {
                                    // Handle YYYY-MM-DD format (ISO) - parse as local time, not UTC
                                    const parts = selectedDate.split('-');
                                    const year = parseInt(parts[0], 10);
                                    const month = parseInt(parts[1], 10) - 1; // JavaScript months are 0-indexed
                                    const day = parseInt(parts[2], 10);
                                    date = new Date(year, month, day);
                                  }
                                  const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                                  return monthNames[date.getMonth()];
                                })() : 'N/A'}
                              />
                            </div>
                          </div>

                          <div className="lg:col-span-8 space-y-4">
                            <div className="flex items-center justify-between mb-2">
                              <h3 className="text-sm font-semibold text-gray-900 uppercase tracking-wider">Extracted Options</h3>
                              <span className="text-xs text-gray-500">Select the correct extraction below</span>
                            </div>
                            <div className="space-y-3">
                              {(activeTab === 'EXTRACTED' ? [...editedResult.extractedEntries].reverse() : editedResult.extractedEntries).map((entry, idx) => {
                                // Calculate original index for proper reference
                                const originalIdx = activeTab === 'EXTRACTED' 
                                  ? editedResult.extractedEntries.length - 1 - idx 
                                  : idx;
                                const editedEntry = editedResult.extractedEntries[originalIdx];
                                const isSelected = editedEntry.isSelected !== undefined ? editedEntry.isSelected : (originalIdx === editedResult.extractedEntries.length - 1);
                                const entrySupplierName = editedEntry.editedSupplierName !== undefined && editedEntry.editedSupplierName !== null 
                                  ? editedEntry.editedSupplierName 
                                  : (editedEntry.supplier || 'General');
                                const entryCost = editedEntry.editedCost !== null && editedEntry.editedCost !== undefined ? editedEntry.editedCost : editedEntry.amount;
                                
                                // Calculate default date: use extracted month if available, otherwise one week ago
                                let defaultDateString;
                                if (editedEntry.month) {
                                  // Convert month name to date (use first day of that month)
                                  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                                  const monthIndex = monthNames.indexOf(editedEntry.month);
                                  if (monthIndex !== -1) {
                                    const now = new Date();
                                    const currentYear = now.getFullYear();
                                    const currentMonth = now.getMonth();
                                    // Use the extracted month, first day of month
                                    // If the extracted month is later in the year than current month, use previous year
                                    const year = monthIndex > currentMonth ? currentYear - 1 : currentYear;
                                    const extractedDate = new Date(year, monthIndex, 1);
                                    defaultDateString = extractedDate.toISOString().split('T')[0];
                                  } else {
                                    // Fallback: one week ago
                                    const defaultDate = new Date();
                                    defaultDate.setDate(defaultDate.getDate() - 7);
                                    defaultDateString = defaultDate.toISOString().split('T')[0];
                                  }
                                } else {
                                  // Default date: one week ago
                                  const defaultDate = new Date();
                                  defaultDate.setDate(defaultDate.getDate() - 7);
                                  defaultDateString = defaultDate.toISOString().split('T')[0];
                                }
                                
                                const entryDate = editedEntry.editedEffectiveDate || defaultDateString;
                                const entryAddToHistory = editedEntry.addToHistory !== undefined ? editedEntry.addToHistory : true;
                                
                                // Format date for display
                                const displayDate = entryDate ? (() => {
                                  let date;
                                  if (entryDate.includes('/')) {
                                    const parts = entryDate.split('/');
                                    const month = parseInt(parts[0], 10) - 1;
                                    const day = parseInt(parts[1], 10);
                                    const year = parseInt(parts[2], 10);
                                    date = new Date(year, month, day);
                                  } else {
                                    const parts = entryDate.split('-');
                                    const year = parseInt(parts[0], 10);
                                    const month = parseInt(parts[1], 10) - 1;
                                    const day = parseInt(parts[2], 10);
                                    date = new Date(year, month, day);
                                  }
                                  const monthNames = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'];
                                  const dayNames = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31'];
                                  return `${monthNames[date.getMonth()]}/${dayNames[date.getDate() - 1]}/${date.getFullYear()}`;
                                })() : '';
                                
                                // Confidence badge styling
                                const confidenceClass = entry.confidence === 'HIGH' 
                                  ? 'text-green-600 border-green-200 bg-green-50' 
                                  : entry.confidence === 'MEDIUM'
                                  ? 'text-gray-500 border-gray-200'
                                  : 'text-orange-600 border-orange-200 bg-orange-50';
                                
                                return (
                                  <div 
                                    key={`${result.productId}-${originalIdx}`} 
                                    className={`relative border rounded-lg p-4 transition-colors cursor-pointer group ${
                                      isSelected 
                                        ? 'border-2 border-primary bg-blue-50/50 shadow-sm ring-1 ring-primary/10' 
                                        : 'border-gray-200 bg-white hover:bg-gray-50'
                                    }`}
                                  >
                                    {isSelected && (
                                      <div className="absolute top-0 left-0 w-full h-1 bg-primary rounded-t-lg"></div>
                                    )}
                                    {!isSelected && (
                                      <div className="absolute top-0 left-0 w-full h-1 bg-gray-200 rounded-t-lg group-hover:bg-gray-300 transition-colors"></div>
                                    )}
                                    <div className="flex items-start gap-4">
                                      <div className="pt-1 flex flex-col items-center gap-1">
                                        <input
                                          type="radio"
                                          name={`selected_${result.productId}`}
                                          checked={isSelected}
                                          onChange={() => {
                                            const newResults = { ...editedResults };
                                            if (!newResults[result.productId]) {
                                              newResults[result.productId] = { ...result };
                                            }
                                            if (!newResults[result.productId].extractedEntries) {
                                              newResults[result.productId].extractedEntries = [...result.extractedEntries];
                                            }
                                            // Unselect all entries for this product
                                            newResults[result.productId].extractedEntries = newResults[result.productId].extractedEntries.map((e, i) => ({
                                              ...e,
                                              isSelected: i === originalIdx,
                                            }));
                                            // Update selected cost and supplier
                                            newResults[result.productId].selectedCost = entryCost;
                                            newResults[result.productId].selectedSupplierName = entrySupplierName;
                                            newResults[result.productId].selectedSupplierId = editedEntry.supplierId || null;
                                            setEditedExtractionResults(newResults);
                                          }}
                                          className="h-4 w-4 text-primary border-gray-300 focus:ring-primary"
                                        />
                                        {isSelected && <span className="material-icons text-primary text-sm font-bold">check</span>}
                                      </div>
                                      <div className="flex-1 space-y-3">
                                        <div className="flex items-center justify-between">
                                          <div className="bg-yellow-100 text-yellow-800 px-2 py-1 rounded text-xs font-mono">
                                            Original: {entry.originalLine}
                                          </div>
                                          <div className="flex items-center gap-2">
                                            <input
                                              type="checkbox"
                                              checked={entryAddToHistory}
                                              onChange={(e) => {
                                                const newResults = { ...editedResults };
                                                if (!newResults[result.productId]) {
                                                  newResults[result.productId] = { ...result };
                                                }
                                                if (!newResults[result.productId].extractedEntries[originalIdx]) {
                                                  newResults[result.productId].extractedEntries = [...result.extractedEntries];
                                                }
                                                newResults[result.productId].extractedEntries[originalIdx] = {
                                                  ...newResults[result.productId].extractedEntries[originalIdx],
                                                  addToHistory: e.target.checked,
                                                };
                                                setEditedExtractionResults(newResults);
                                              }}
                                              className="h-3 w-3 rounded text-primary border-gray-300 focus:ring-primary"
                                            />
                                            <span className="text-xs font-medium text-gray-500">History</span>
                                          </div>
                                        </div>
                                        <div className="grid grid-cols-1 md:grid-cols-12 gap-3 items-end">
                                          <div className="md:col-span-6 space-y-1">
                                            <label className="text-xs text-gray-500">Supplier</label>
                                            <div className="relative autocomplete-container">
                                              <input
                                                type="text"
                                                value={entrySupplierName}
                                                onChange={(e) => {
                                                  const inputValue = e.target.value;
                                                  const originalSupplierName = entry.supplier;
                                                  const newSupplierName = inputValue;
                                                  
                                                  // Update state with the input value (no auto-select when typing)
                                                  setEditedExtractionResults(prevResults => {
                                                    const newResults = { ...prevResults };
                                                    if (!newResults[result.productId]) {
                                                      newResults[result.productId] = { ...result };
                                                    }
                                                    if (!newResults[result.productId].extractedEntries) {
                                                      newResults[result.productId].extractedEntries = [...result.extractedEntries];
                                                    }
                                                    if (!newResults[result.productId].extractedEntries[originalIdx]) {
                                                      newResults[result.productId].extractedEntries[originalIdx] = { ...result.extractedEntries[originalIdx] };
                                                    }
                                                    newResults[result.productId].extractedEntries[originalIdx] = {
                                                      ...newResults[result.productId].extractedEntries[originalIdx],
                                                      editedSupplierName: newSupplierName,
                                                      supplierId: null,
                                                    };
                                                    if (isSelected) {
                                                      newResults[result.productId].selectedSupplierName = newSupplierName;
                                                      newResults[result.productId].selectedSupplierId = null;
                                                    }
                                                    return newResults;
                                                  });
                                                  
                                                  // Update supplier name mapping if name changed
                                                  // DO NOT track mappings for Unknown/General/null suppliers
                                                  const isUnknownOrGeneral = !originalSupplierName || originalSupplierName === 'Unknown' || originalSupplierName === 'General';
                                                  
                                                  if (!isUnknownOrGeneral && newSupplierName !== originalSupplierName && newSupplierName.trim() !== '') {
                                                    setSupplierNameMappings(prev => {
                                                      // Remove existing mapping for this original name if it exists
                                                      const filtered = prev.filter(m => m.supplierOriginal !== originalSupplierName);
                                                      // Add or update the mapping
                                                      return [...filtered, { supplierOriginal: originalSupplierName, new: newSupplierName }];
                                                    });
                                                  }
                                                  
                                                  if (inputValue.length > 0) {
                                                    // First, try local matching (initials, mappings, names)
                                                    const localSuggestions = getSupplierSuggestions(inputValue, originalSupplierName);
                                                    
                                                    if (localSuggestions.length > 0) {
                                                      setOpenAutocomplete(prev => ({ ...prev, [`${result.productId}_${originalIdx}`]: true }));
                                                      setSupplierSuggestions(prev => ({
                                                        ...prev,
                                                        [`${result.productId}_${originalIdx}`]: localSuggestions
                                                      }));
                                                    } else if (inputValue.length > 1) {
                                                      // Fallback to API call if no local matches
                                                      setOpenAutocomplete(prev => ({ ...prev, [`${result.productId}_${originalIdx}`]: true }));
                                                      fetch(`/admin/inventory/cutover/suppliers/suggest?q=${encodeURIComponent(inputValue)}`)
                                                        .then(res => res.json())
                                                        .then(data => {
                                                          if (data.success) {
                                                            setSupplierSuggestions(prev => ({
                                                              ...prev,
                                                              [`${result.productId}_${originalIdx}`]: data.suppliers
                                                            }));
                                                          }
                                                        })
                                                        .catch(err => console.error('Failed to fetch suggestions:', err));
                                                    } else {
                                                      setOpenAutocomplete(prev => {
                                                        const newState = { ...prev };
                                                        delete newState[`${result.productId}_${originalIdx}`];
                                                        return newState;
                                                      });
                                                    }
                                                  } else {
                                                    setOpenAutocomplete(prev => {
                                                      const newState = { ...prev };
                                                      delete newState[`${result.productId}_${originalIdx}`];
                                                      return newState;
                                                    });
                                                  }
                                                }}
                                                onBlur={(e) => {
                                                  const inputKey = `${result.productId}_${originalIdx}`;
                                                  
                                                  // Skip if dropdown selection was just made
                                                  if (dropdownSelectionRef.current[inputKey]) {
                                                    delete dropdownSelectionRef.current[inputKey];
                                                    return;
                                                  }
                                                  
                                                  // Close autocomplete on blur
                                                  setTimeout(() => {
                                                    setOpenAutocomplete(prev => {
                                                      const newState = { ...prev };
                                                      delete newState[inputKey];
                                                      return newState;
                                                    });
                                                  }, 200);
                                                }}
                                                className={`block w-full rounded-md border shadow-sm focus:border-primary focus:ring-primary sm:text-sm ${
                                                  isSelected 
                                                    ? 'border-primary bg-white' 
                                                    : 'border-gray-300 bg-white'
                                                }`}
                                              />
                                              {openAutocomplete[`${result.productId}_${originalIdx}`] && supplierSuggestions[`${result.productId}_${originalIdx}`] && supplierSuggestions[`${result.productId}_${originalIdx}`].length > 0 && (
                                                <div className="absolute top-full left-0 right-0 bg-white border border-gray-300 rounded-md mt-1 z-50 max-h-32 overflow-y-auto shadow-lg">
                                                  {supplierSuggestions[`${result.productId}_${originalIdx}`].map((supplier, suggestionIdx) => (
                                                    <div
                                                      key={supplier.id || `suggestion-${suggestionIdx}`}
                                                      onMouseDown={(e) => {
                                                        // Prevent input blur when clicking dropdown
                                                        e.preventDefault();
                                                      }}
                                                      onClick={(e) => {
                                                        const originalSupplierName = entry.supplier;
                                                        const newSupplierName = supplier.name;
                                                        const inputKey = `${result.productId}_${originalIdx}`;
                                                        
                                                        // Find the input element and update its value immediately
                                                        // This ensures onBlur (if it fires) reads the correct value
                                                        const inputElement = e.target.closest('.autocomplete-container')?.querySelector('input[type="text"]');
                                                        if (inputElement) {
                                                          inputElement.value = newSupplierName;
                                                        }
                                                        
                                                        // Mark that dropdown selection was made to prevent onBlur from using wrong value
                                                        dropdownSelectionRef.current[inputKey] = true;
                                                        
                                                        const newResults = { ...editedResults };
                                                        if (!newResults[result.productId]) {
                                                          newResults[result.productId] = { ...result };
                                                        }
                                                        if (!newResults[result.productId].extractedEntries[originalIdx]) {
                                                          newResults[result.productId].extractedEntries = [...result.extractedEntries];
                                                        }
                                                        newResults[result.productId].extractedEntries[originalIdx] = {
                                                          ...newResults[result.productId].extractedEntries[originalIdx],
                                                          supplierId: supplier.id,
                                                          editedSupplierName: supplier.name,
                                                        };
                                                        if (isSelected) {
                                                          newResults[result.productId].selectedSupplierName = supplier.name;
                                                          newResults[result.productId].selectedSupplierId = supplier.id;
                                                        }
                                                        setEditedExtractionResults(newResults);
                                                        
                                                        // Update supplier name mapping if name changed
                                                        // DO NOT track mappings for Unknown/General/null suppliers
                                                        const isUnknownOrGeneral = !originalSupplierName || originalSupplierName === 'Unknown' || originalSupplierName === 'General';
                                                        
                                                        if (!isUnknownOrGeneral && newSupplierName !== originalSupplierName && newSupplierName.trim() !== '') {
                                                          setSupplierNameMappings(prev => {
                                                            // Remove existing mapping for this original name if it exists
                                                            const filtered = prev.filter(m => m.supplierOriginal !== originalSupplierName);
                                                            // Add or update the mapping
                                                            return [...filtered, { supplierOriginal: originalSupplierName, new: newSupplierName }];
                                                          });
                                                        }
                                                        
                                                        setOpenAutocomplete(prev => {
                                                          const newState = { ...prev };
                                                          delete newState[`${result.productId}_${originalIdx}`];
                                                          return newState;
                                                        });
                                                        setSupplierSuggestions(prev => {
                                                          const newSuggestions = { ...prev };
                                                          delete newSuggestions[`${result.productId}_${originalIdx}`];
                                                          return newSuggestions;
                                                        });
                                                      }}
                                                      className="px-3 py-2 cursor-pointer border-b border-gray-100 text-sm hover:bg-gray-50"
                                                    >
                                                      {supplier.name}
                                                    </div>
                                                  ))}
                                                </div>
                                              )}
                                            </div>
                                          </div>
                                          <div className="md:col-span-3 space-y-1">
                                            <label className="text-xs text-gray-500">Cost</label>
                                            <div className="relative rounded-md shadow-sm">
                                              <input
                                                type="number"
                                                step="0.01"
                                                value={entryCost}
                                                onChange={(e) => {
                                                  const newResults = { ...editedResults };
                                                  if (!newResults[result.productId]) {
                                                    newResults[result.productId] = { ...result };
                                                  }
                                                  if (!newResults[result.productId].extractedEntries[idx]) {
                                                    newResults[result.productId].extractedEntries = [...result.extractedEntries];
                                                  }
                                                  const newCost = parseFloat(e.target.value) || null;
                                                  newResults[result.productId].extractedEntries[idx] = {
                                                    ...newResults[result.productId].extractedEntries[idx],
                                                    editedCost: newCost,
                                                  };
                                                  if (isSelected) {
                                                    newResults[result.productId].selectedCost = newCost;
                                                  }
                                                  setEditedExtractionResults(newResults);
                                                }}
                                                className={`block w-full rounded-md border pr-8 shadow-sm focus:border-primary focus:ring-primary sm:text-sm text-right ${
                                                  isSelected 
                                                    ? 'border-primary bg-white font-medium' 
                                                    : 'border-gray-300 bg-white'
                                                }`}
                                              />
                                              <div className="absolute inset-y-0 right-0 flex items-center pr-3 pointer-events-none">
                                                <span className="material-icons text-gray-400 text-xs">unfold_more</span>
                                              </div>
                                            </div>
                                          </div>
                                          <div className="md:col-span-3 space-y-1">
                                            <label className="text-xs text-gray-500">Date</label>
                                            <input
                                              type="date"
                                              value={entryDate}
                                              onChange={(e) => {
                                                const newResults = { ...editedResults };
                                                if (!newResults[result.productId]) {
                                                  newResults[result.productId] = { ...result };
                                                }
                                                if (!newResults[result.productId].extractedEntries[idx]) {
                                                  newResults[result.productId].extractedEntries = [...result.extractedEntries];
                                                }
                                                newResults[result.productId].extractedEntries[idx] = {
                                                  ...newResults[result.productId].extractedEntries[idx],
                                                  editedEffectiveDate: e.target.value,
                                                };
                                                setEditedExtractionResults(newResults);
                                              }}
                                              className={`block w-full rounded-md border shadow-sm focus:border-primary focus:ring-primary sm:text-sm text-center ${
                                                isSelected 
                                                  ? 'border-primary bg-white' 
                                                  : 'border-gray-300 bg-white'
                                              }`}
                                            />
                                          </div>
                                        </div>
                                        <div className="flex items-center gap-3">
                                          <span className={`text-xs font-semibold border px-1.5 py-0.5 rounded uppercase ${confidenceClass}`}>
                                            {entry.confidence} Confidence
                                          </span>
                                          {entry.month && (
                                            <span className="text-xs text-gray-500">Month extracted: {entry.month}</span>
                                          )}
                                        </div>
                                      </div>
                                    </div>
                                  </div>
                                );
                              })}
                            </div>
                          </div>
                        </div>
                      ) : (
                        <div className="p-6 grid grid-cols-1 lg:grid-cols-12 gap-8">
                          <div className="lg:col-span-4 space-y-5">
                            {/* Product Image */}
                            <div className="w-full bg-gray-200 rounded-lg flex items-center justify-center relative" style={{ height: '200px', minHeight: '200px' }}>
                              {result.imageUrl ? (
                                <>
                                  <img 
                                    src={result.imageUrl} 
                                    alt={result.productName}
                                    className="w-full h-full object-cover rounded-lg"
                                    onError={(e) => {
                                      // Hide image and show placeholder if image fails to load
                                      e.target.style.display = 'none';
                                      const placeholder = e.target.parentElement?.querySelector('.image-placeholder');
                                      if (placeholder) {
                                        placeholder.style.display = 'flex';
                                      }
                                    }}
                                  />
                                  <div className="image-placeholder absolute inset-0 w-full h-full bg-gray-200 rounded-lg flex items-center justify-center" style={{ display: 'none' }}>
                                    <div className="text-center">
                                      <span className="material-icons text-gray-400 text-6xl">image</span>
                                      <p className="text-xs text-gray-500 mt-2">No Product Image</p>
                                    </div>
                                  </div>
                                </>
                              ) : (
                                <div className="text-center">
                                  <span className="material-icons text-gray-400 text-6xl">image</span>
                                  <p className="text-xs text-gray-500 mt-2">No Product Image</p>
                                </div>
                              )}
                            </div>
                            
                            {/* Product Name - Two Lines */}
                            <div>
                              <h2 className="text-xl font-bold text-gray-900">{productMainName}</h2>
                              {productBrand && <p className="text-xl font-bold text-gray-900">{productBrand}</p>}
                            </div>
                            
                            {/* Separator */}
                            <div className="border-t border-gray-200 my-4"></div>
                            
                            <div className="space-y-1">
                              <label className="block text-xs font-medium text-gray-500 uppercase">Supplier Name</label>
                              <div className="relative autocomplete-container">
                                <input
                                  type="text"
                                  value={editedResult.selectedSupplierName ?? ''}
                                  onChange={(e) => {
                                    const inputValue = e.target.value;
                                    const originalSupplierName = result.selectedSupplierName;
                                    const newSupplierName = inputValue;
                                    
                                    // Update state with the input value (no auto-select for manual input)
                                    setEditedExtractionResults(prevResults => {
                                      const newResults = { ...prevResults };
                                      if (!newResults[result.productId]) {
                                        newResults[result.productId] = { ...result };
                                      }
                                      newResults[result.productId].selectedSupplierName = newSupplierName;
                                      newResults[result.productId].selectedSupplierId = null;
                                      return newResults;
                                    });
                                    
                                    // Update supplier name mapping if name changed
                                    // DO NOT track mappings for Unknown/General/null suppliers
                                    const isUnknownOrGeneral = !originalSupplierName || originalSupplierName === 'Unknown' || originalSupplierName === 'General';
                                    
                                    if (!isUnknownOrGeneral && newSupplierName !== originalSupplierName && newSupplierName.trim() !== '') {
                                      setSupplierNameMappings(prev => {
                                        // Remove existing mapping for this original name if it exists
                                        const filtered = prev.filter(m => m.supplierOriginal !== originalSupplierName);
                                        // Add or update the mapping
                                        return [...filtered, { supplierOriginal: originalSupplierName, new: newSupplierName }];
                                      });
                                    }
                                    
                                    if (inputValue.length > 0) {
                                      // First, try local matching (initials, mappings, names)
                                      const localSuggestions = getSupplierSuggestions(inputValue, originalSupplierName);
                                      
                                      if (localSuggestions.length > 0) {
                                        setOpenAutocomplete(prev => ({ ...prev, [result.productId]: true }));
                                        setSupplierSuggestions(prev => ({
                                          ...prev,
                                          [result.productId]: localSuggestions
                                        }));
                                      } else if (inputValue.length > 1) {
                                        // Fallback to API call if no local matches
                                        setOpenAutocomplete(prev => ({ ...prev, [result.productId]: true }));
                                        fetch(`/admin/inventory/cutover/suppliers/suggest?q=${encodeURIComponent(inputValue)}`)
                                          .then(res => res.json())
                                          .then(data => {
                                            if (data.success) {
                                              setSupplierSuggestions(prev => ({
                                                ...prev,
                                                [result.productId]: data.suppliers
                                              }));
                                            }
                                          })
                                          .catch(err => console.error('Failed to fetch suggestions:', err));
                                      } else {
                                        setOpenAutocomplete(prev => {
                                          const newState = { ...prev };
                                          delete newState[result.productId];
                                          return newState;
                                        });
                                      }
                                    } else if (inputValue.length === 0) {
                                      setOpenAutocomplete(prev => {
                                        const newState = { ...prev };
                                        delete newState[result.productId];
                                        return newState;
                                      });
                                    }
                                  }}
                                  onFocus={() => {
                                    if (supplierSuggestions[result.productId] && supplierSuggestions[result.productId].length > 0) {
                                      setOpenAutocomplete(prev => ({ ...prev, [result.productId]: true }));
                                    }
                                  }}
                                  placeholder="Enter supplier name"
                                  className="block w-full rounded-md border-gray-300 shadow-sm focus:border-primary focus:ring-primary sm:text-sm bg-white"
                                />
                                {openAutocomplete[result.productId] && supplierSuggestions[result.productId] && supplierSuggestions[result.productId].length > 0 && (
                                  <div className="absolute top-full left-0 right-0 bg-white border border-gray-300 rounded-md mt-1 z-50 max-h-48 overflow-y-auto shadow-lg">
                                    {supplierSuggestions[result.productId].map((supplier, suggestionIdx) => (
                                      <div
                                        key={supplier.id || `suggestion-${suggestionIdx}`}
                                        onClick={() => {
                                          const originalSupplierName = result.selectedSupplierName;
                                          const newSupplierName = supplier.name;
                                          
                                          const newResults = { ...editedResults };
                                          if (!newResults[result.productId]) {
                                            newResults[result.productId] = { ...result };
                                          }
                                          newResults[result.productId].selectedSupplierId = supplier.id;
                                          newResults[result.productId].selectedSupplierName = supplier.name;
                                          setEditedExtractionResults(newResults);
                                          
                                          // Update supplier name mapping if name changed
                                          // DO NOT track mappings for Unknown/General/null suppliers
                                          const isUnknownOrGeneral = !originalSupplierName || originalSupplierName === 'Unknown' || originalSupplierName === 'General';
                                          
                                          if (!isUnknownOrGeneral && newSupplierName !== originalSupplierName && newSupplierName.trim() !== '') {
                                            setSupplierNameMappings(prev => {
                                              // Remove existing mapping for this original name if it exists
                                              const filtered = prev.filter(m => m.supplierOriginal !== originalSupplierName);
                                              // Add or update the mapping
                                              return [...filtered, { supplierOriginal: originalSupplierName, new: newSupplierName }];
                                            });
                                          }
                                          setOpenAutocomplete(prev => {
                                            const newState = { ...prev };
                                            delete newState[result.productId];
                                            return newState;
                                          });
                                          setSupplierSuggestions(prev => {
                                            const newSuggestions = { ...prev };
                                            delete newSuggestions[result.productId];
                                            return newSuggestions;
                                          });
                                        }}
                                        className="px-3 py-2 cursor-pointer border-b border-gray-100 hover:bg-gray-50"
                                      >
                                        {supplier.name}
                                      </div>
                                    ))}
                                  </div>
                                )}
                              </div>
                            </div>
                            <div className="space-y-1">
                              <label className="block text-xs font-medium text-gray-500 uppercase">Cost</label>
                              <div className="relative rounded-md shadow-sm">
                                <div className="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3">
                                  <span className="text-gray-500 sm:text-sm">$</span>
                                </div>
                                <input
                                  type="number"
                                  step="0.01"
                                  value={editedResult.selectedCost || ''}
                                  onChange={(e) => {
                                    const newResults = { ...editedResults };
                                    if (!newResults[result.productId]) {
                                      newResults[result.productId] = { ...result };
                                    }
                                    newResults[result.productId].selectedCost = parseFloat(e.target.value) || null;
                                    setEditedExtractionResults(newResults);
                                  }}
                                  placeholder="0.00"
                                  style={{ paddingLeft: '21px' }}
                                  className="block w-full rounded-md border-gray-300 shadow-sm focus:border-primary focus:ring-primary sm:text-sm bg-white"
                                />
                              </div>
                            </div>
                            <div className="space-y-1">
                              <label className="block text-xs font-medium text-gray-500 uppercase">Preferred Supplier</label>
                              <input 
                                className="block w-full rounded-md border-gray-300 bg-gray-50 text-gray-900 shadow-sm focus:border-primary focus:ring-primary sm:text-sm" 
                                readOnly 
                                type="text" 
                                value={editedResult.selectedSupplierName || 'N/A'}
                              />
                            </div>
                            <div className="space-y-1">
                              <label className="block text-xs font-medium text-gray-500 uppercase">Cost History Date</label>
                              <input 
                                className="block w-full rounded-md border-gray-300 bg-gray-50 text-gray-900 shadow-sm focus:border-primary focus:ring-primary sm:text-sm" 
                                readOnly 
                                type="text" 
                                value="N/A"
                              />
                            </div>
                          </div>
                          <div className="lg:col-span-8">
                            <div className="bg-red-50 border border-red-200 rounded-lg p-4">
                              <div className="flex items-start justify-between gap-4">
                                <div>
                                  <p className="text-sm text-red-800 font-medium mb-2">No cost extracted - manual input required</p>
                                  <p className="text-xs text-red-600">Please enter the supplier name and cost above.</p>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>

              <div className="px-6 py-4 bg-gray-50 border-t border-gray-200 flex justify-end gap-3">
                {!extractionResult.isComplete && (
                  <button 
                    onClick={() => {
                      handleExtractCosts(true);
                    }}
                    disabled={loading}
                    className="px-4 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    {loading ? 'Processing Batch...' : `Continue Extraction Batch ${extractionResult.currentBatch + 1}/${extractionResult.totalBatches}`}
                  </button>
                )}
                <button 
                  onClick={currentBatchId && extractionSessionId ? handleApproveBatch : handleApproveCosts}
                  disabled={loading || (currentBatchId && (!extractionApproved || !manualInputApproved))} 
                  className="px-4 py-2 bg-primary hover:bg-primary-hover text-white rounded-md text-sm font-medium shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {loading ? 'Approving...' : currentBatchId ? 'Approve Batch & Continue' : (extractionResult.isComplete ? 'Approve All Costs' : `Approve Extracted Costs (${extractionResult.processedItems} items)`)}
                </button>
              </div>
            </div>
          )}

          {step === 'migrate' && (
            <div className="space-y-6">
              <div>
                <h3 className="text-xl font-bold text-gray-900 mb-2">Ready to Migrate</h3>
                <p className="text-gray-600">Costs have been approved. You can preview the migration or proceed directly.</p>
              </div>
              
              {migrationResult && !migrationResult.isComplete && (
                <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                  <h4 className="font-semibold text-yellow-800 mb-2">Batch Progress</h4>
                  <p className="text-sm text-yellow-700 mb-1"><strong>Batch:</strong> {migrationResult.currentBatch} / {migrationResult.totalBatches}</p>
                  <p className="text-sm text-yellow-700 mb-3"><strong>Processed:</strong> {migrationResult.processedItems} / {migrationResult.totalItems} items</p>
                  <div className="bg-gray-200 rounded-full h-2 overflow-hidden">
                    <div 
                      className="bg-green-600 h-full transition-all duration-300"
                      style={{ width: `${(migrationResult.processedItems / migrationResult.totalItems) * 100}%` }}
                    ></div>
                  </div>
                  <p className="text-sm text-yellow-700 mt-3">
                    Products Processed: {migrationResult.productsProcessed} | 
                    Opening Balances Created: {migrationResult.openingBalancesCreated}
                  </p>
                  {migrationResult.errors.length > 0 && (
                    <div className="mt-3 p-3 bg-white rounded border border-yellow-300">
                      <strong className="text-yellow-800">Errors:</strong> <span className="text-yellow-700">{migrationResult.errors.length}</span>
                    </div>
                  )}
                </div>
              )}
              
              <div className="flex gap-3">
                {!migrationResult && (
                  <>
                    <button 
                      onClick={handlePreview} 
                      disabled={loading}
                      className="px-4 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      {loading ? 'Previewing...' : 'Preview Migration'}
                    </button>
                    <button 
                      onClick={() => handleMigrate(false)} 
                      disabled={loading}
                      className="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-md text-sm font-medium shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      {loading ? 'Migrating...' : 'Execute Migration'}
                    </button>
                  </>
                )}
                {migrationResult && !migrationResult.isComplete && (
                  <button 
                    onClick={() => handleMigrate(true)} 
                    disabled={loading}
                    className="px-4 py-2 bg-primary hover:bg-primary-hover text-white rounded-md text-sm font-medium shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    {loading ? 'Processing Batch...' : `Continue Batch ${migrationResult.currentBatch + 1}/${migrationResult.totalBatches}`}
                  </button>
                )}
              </div>

              {previewResult && (
                <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
                  <h4 className="font-semibold text-gray-900 mb-3">Preview Results</h4>
                  <div className="grid grid-cols-2 gap-4 text-sm">
                    <div>
                      <span className="text-gray-600">Total Products:</span>
                      <span className="ml-2 font-semibold text-gray-900">{previewResult.totalProducts}</span>
                    </div>
                    <div>
                      <span className="text-gray-600">Products with Cost:</span>
                      <span className="ml-2 font-semibold text-green-600">{previewResult.productsWithCost}</span>
                    </div>
                    <div>
                      <span className="text-gray-600">Products Missing Cost:</span>
                      <span className="ml-2 font-semibold text-orange-600">{previewResult.productsMissingCost}</span>
                    </div>
                    <div>
                      <span className="text-gray-600">Estimated Opening Balances:</span>
                      <span className="ml-2 font-semibold text-gray-900">{previewResult.estimatedOpeningBalances}</span>
                    </div>
                  </div>
                </div>
              )}
            </div>
          )}

          {step === 'complete' && migrationResult && (
            <div className="bg-green-50 border border-green-200 rounded-lg p-6 text-green-800">
              <h3 className="text-xl font-bold mb-4">Migration Completed Successfully!</h3>
              <div className="space-y-2 text-sm">
                <p><strong>Cutover Date:</strong> {new Date(migrationResult.cutoverDate).toLocaleString()}</p>
                <p><strong>Locations Processed:</strong> {migrationResult.locationsProcessed}</p>
                <p><strong>Products Processed:</strong> {migrationResult.productsProcessed}</p>
                <p><strong>Opening Balances Created:</strong> {migrationResult.openingBalancesCreated}</p>
                {migrationResult.batchSize && (
                  <p><strong>Processed in:</strong> {migrationResult.totalBatches} batch(es) of {migrationResult.batchSize} items</p>
                )}
                {migrationResult.errors.length > 0 && (
                  <div className="mt-4 p-3 bg-white rounded border border-green-300">
                    <strong className="text-green-800">Errors:</strong>
                    <ul className="mt-2 list-disc list-inside">
                      {migrationResult.errors.map((err, idx) => (
                        <li key={idx} className="text-green-700">{err.message}</li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      );
    }

    function Suppliers() {
      const [activeSubsection, setActiveSubsection] = useState('management'); // 'management', 'products', 'cost-history'
      const [suppliers, setSuppliers] = useState([]);
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState(null);
      const [editingId, setEditingId] = useState(null);
      const [formData, setFormData] = useState({ name: '', initials: [], contactInfo: '', isActive: true });
      const [newInitial, setNewInitial] = useState('');
      const [showAddForm, setShowAddForm] = useState(false);
      const [filterActive, setFilterActive] = useState(true);

      const fetchSuppliers = async () => {
        setLoading(true);
        setError(null);
        try {
          const response = await fetch('/admin/inventory/cutover/suppliers');
          const data = await response.json();
          if (data.success) {
            setSuppliers(data.suppliers);
          } else {
            setError(data.message || 'Failed to fetch suppliers');
          }
        } catch (err) {
          setError(err.message || 'Failed to fetch suppliers');
        } finally {
          setLoading(false);
        }
      };

      useEffect(() => {
        fetchSuppliers();
      }, []);

      const handleCreate = async () => {
        if (!formData.name.trim()) {
          setError('Supplier name is required');
          return;
        }
        setLoading(true);
        setError(null);
        try {
          const response = await fetch('/admin/inventory/cutover/suppliers', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              name: formData.name.trim(),
              initials: formData.initials.filter(i => i && i.trim().length > 0).map(i => i.trim()),
              contactInfo: formData.contactInfo.trim() || null,
            }),
          });
          const data = await response.json();
          if (data.success) {
            await fetchSuppliers();
            setFormData({ name: '', initials: [], contactInfo: '', isActive: true });
            setNewInitial('');
            setShowAddForm(false);
          } else {
            setError(data.message || 'Failed to create supplier');
          }
        } catch (err) {
          setError(err.message || 'Failed to create supplier');
        } finally {
          setLoading(false);
        }
      };

      const handleUpdate = async (id) => {
        if (!formData.name.trim()) {
          setError('Supplier name is required');
          return;
        }
        setLoading(true);
        setError(null);
        try {
          const response = await fetch(`/admin/inventory/cutover/suppliers/${id}/update`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              name: formData.name.trim(),
              initials: formData.initials.filter(i => i && i.trim().length > 0).map(i => i.trim()),
              contactInfo: formData.contactInfo.trim() || null,
              isActive: formData.isActive,
            }),
          });
          const data = await response.json();
          if (data.success) {
            await fetchSuppliers();
            setEditingId(null);
            setFormData({ name: '', initials: [], contactInfo: '', isActive: true });
            setNewInitial('');
          } else {
            setError(data.message || 'Failed to update supplier');
          }
        } catch (err) {
          setError(err.message || 'Failed to update supplier');
        } finally {
          setLoading(false);
        }
      };

      const handleDelete = async (id) => {
        if (!confirm('Are you sure you want to deactivate this supplier?')) {
          return;
        }
        setLoading(true);
        setError(null);
        try {
          const response = await fetch(`/admin/inventory/cutover/suppliers/${id}/delete`, {
            method: 'POST',
          });
          const data = await response.json();
          if (data.success) {
            await fetchSuppliers();
          } else {
            setError(data.message || 'Failed to delete supplier');
          }
        } catch (err) {
          setError(err.message || 'Failed to delete supplier');
        } finally {
          setLoading(false);
        }
      };

      const startEdit = (supplier) => {
        setEditingId(supplier.id);
        setFormData({
          name: supplier.name,
          initials: Array.isArray(supplier.initials) ? supplier.initials : (supplier.initials ? [supplier.initials] : []),
          contactInfo: supplier.contactInfo || '',
          isActive: supplier.isActive,
        });
        setNewInitial('');
        setShowAddForm(false);
      };

      const cancelEdit = () => {
        setEditingId(null);
        setFormData({ name: '', initials: [], contactInfo: '', isActive: true });
        setNewInitial('');
        setShowAddForm(false);
      };

      const filteredSuppliers = filterActive 
        ? suppliers.filter(s => s.isActive)
        : suppliers;

      return (
        <div className="max-w-7xl mx-auto bg-white rounded-xl shadow-sm p-6">
          <div className="mb-6">
            <h2 className="text-2xl font-bold text-gray-900 mb-4">Suppliers</h2>
            {/* Submenu Navigation */}
            <div className="flex gap-2 border-b-2 border-gray-200">
              <button
                onClick={() => setActiveSubsection('management')}
                className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors ${
                  activeSubsection === 'management'
                    ? 'border-primary text-primary font-semibold'
                    : 'border-transparent text-gray-600 hover:text-primary'
                }`}
              >
                Management
              </button>
              <button
                onClick={() => setActiveSubsection('products')}
                className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors ${
                  activeSubsection === 'products'
                    ? 'border-primary text-primary font-semibold'
                    : 'border-transparent text-gray-600 hover:text-primary'
                }`}
              >
                Supplier Products
              </button>
              <button
                onClick={() => setActiveSubsection('cost-history')}
                className={`px-5 py-3 font-medium text-sm border-b-2 transition-colors ${
                  activeSubsection === 'cost-history'
                    ? 'border-primary text-primary font-semibold'
                    : 'border-transparent text-gray-600 hover:text-primary'
                }`}
              >
                Supplier Cost History
              </button>
            </div>
          </div>

          {activeSubsection === 'management' && (
            <>
          <div className="flex justify-between items-center mb-6">
            <h3 className="text-xl font-semibold text-gray-900">Supplier Management</h3>
            <div className="flex gap-3">
              <button
                onClick={() => setFilterActive(!filterActive)}
                className={`px-4 py-2 rounded-md text-sm font-medium ${
                  filterActive
                    ? 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                    : 'bg-primary text-white hover:bg-primary-hover'
                }`}
              >
                {filterActive ? 'Show All' : 'Show Active Only'}
              </button>
              <button
                onClick={() => {
                  cancelEdit();
                  setShowAddForm(true);
                }}
                className="px-4 py-2 bg-primary text-white rounded-md text-sm font-medium hover:bg-primary-hover"
                disabled={loading || editingId}
              >
                + Add Supplier
              </button>
            </div>
          </div>

          {error && (
            <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-md text-red-700 text-sm">
              {error}
            </div>
          )}

          {(showAddForm || editingId) && (
            <div className="mb-6 p-4 bg-gray-50 rounded-lg border border-gray-200">
              <h3 className="text-lg font-semibold text-gray-900 mb-4">
                {editingId ? 'Edit Supplier' : 'Add New Supplier'}
              </h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Supplier Name <span className="text-red-500">*</span>
                  </label>
                  <input
                    type="text"
                    value={formData.name}
                    onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                    placeholder="e.g., Levi Pharmaceuticals"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Initials/Abbreviations
                  </label>
                  <div className="flex gap-2 mb-2">
                    <input
                      type="text"
                      value={newInitial}
                      onChange={(e) => setNewInitial(e.target.value)}
                      onKeyPress={(e) => {
                        if (e.key === 'Enter') {
                          e.preventDefault();
                          const trimmed = newInitial.trim();
                          if (trimmed && !formData.initials.includes(trimmed)) {
                            setFormData({ ...formData, initials: [...formData.initials, trimmed] });
                            setNewInitial('');
                          }
                        }
                      }}
                      className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                      placeholder="e.g., L, Lev, Levi"
                      maxLength={20}
                    />
                    <button
                      type="button"
                      onClick={() => {
                        const trimmed = newInitial.trim();
                        if (trimmed && !formData.initials.includes(trimmed)) {
                          setFormData({ ...formData, initials: [...formData.initials, trimmed] });
                          setNewInitial('');
                        }
                      }}
                      className="px-4 py-2 bg-primary text-white rounded-md hover:bg-primary-hover focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 transition-colors"
                    >
                      Add
                    </button>
                  </div>
                  {formData.initials.length > 0 && (
                    <div className="flex flex-wrap gap-2 mt-2">
                      {formData.initials.map((initial, idx) => (
                        <span
                          key={idx}
                          className="inline-flex items-center gap-1 px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm font-medium"
                        >
                          {initial}
                          <button
                            type="button"
                            onClick={() => {
                              setFormData({
                                ...formData,
                                initials: formData.initials.filter((_, i) => i !== idx),
                              });
                            }}
                            className="ml-1 text-blue-600 hover:text-blue-800 focus:outline-none"
                            aria-label={`Remove ${initial}`}
                          >
                            √ó
                          </button>
                        </span>
                      ))}
                    </div>
                  )}
                  <p className="mt-1 text-xs text-gray-500">Add multiple initials used for cost extraction (e.g., L, Lev, Levi)</p>
                </div>
                <div className="md:col-span-2">
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Contact Info
                  </label>
                  <input
                    type="text"
                    value={formData.contactInfo}
                    onChange={(e) => setFormData({ ...formData, contactInfo: e.target.value })}
                    className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                    placeholder="Email, phone, or address"
                  />
                </div>
                {editingId && (
                  <div>
                    <label className="flex items-center gap-2">
                      <input
                        type="checkbox"
                        checked={formData.isActive}
                        onChange={(e) => setFormData({ ...formData, isActive: e.target.checked })}
                        className="rounded border-gray-300 text-primary focus:ring-primary"
                      />
                      <span className="text-sm font-medium text-gray-700">Active</span>
                    </label>
                  </div>
                )}
              </div>
              <div className="mt-4 flex gap-3">
                <button
                  onClick={editingId ? () => handleUpdate(editingId) : handleCreate}
                  disabled={loading || !formData.name.trim()}
                  className="px-4 py-2 bg-primary text-white rounded-md text-sm font-medium hover:bg-primary-hover disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {loading ? 'Saving...' : editingId ? 'Update' : 'Create'}
                </button>
                <button
                  onClick={cancelEdit}
                  disabled={loading}
                  className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md text-sm font-medium hover:bg-gray-300 disabled:opacity-50"
                >
                  Cancel
                </button>
              </div>
            </div>
          )}

          {loading && !suppliers.length ? (
            <div className="text-center py-12 text-gray-500">Loading suppliers...</div>
          ) : filteredSuppliers.length === 0 ? (
            <div className="text-center py-12 text-gray-500">
              {filterActive ? 'No active suppliers found.' : 'No suppliers found.'}
            </div>
          ) : (
            <div className="overflow-x-auto">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Name
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Initials
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Contact Info
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Status
                    </th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Actions
                    </th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {filteredSuppliers.map((supplier) => (
                    <tr key={supplier.id} className={!supplier.isActive ? 'bg-gray-50 opacity-60' : ''}>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="text-sm font-medium text-gray-900">{supplier.name}</div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="text-sm text-gray-600">
                          {supplier.initials ? (
                            <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">
                              {supplier.initials}
                            </span>
                          ) : (
                            <span className="text-gray-400">‚Äî</span>
                          )}
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="text-sm text-gray-600">{supplier.contactInfo || '‚Äî'}</div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                          supplier.isActive
                            ? 'bg-green-100 text-green-800'
                            : 'bg-gray-100 text-gray-800'
                        }`}>
                          {supplier.isActive ? 'Active' : 'Inactive'}
                        </span>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm font-medium">
                        <div className="flex gap-2">
                          <button
                            onClick={() => startEdit(supplier)}
                            disabled={loading || editingId || showAddForm}
                            className="text-primary hover:text-primary-hover disabled:opacity-50 disabled:cursor-not-allowed"
                          >
                            Edit
                          </button>
                          {supplier.isActive && (
                            <button
                              onClick={() => handleDelete(supplier.id)}
                              disabled={loading || editingId}
                              className="text-red-600 hover:text-red-800 disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                              Deactivate
                            </button>
                          )}
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}

          <div className="mt-4 text-sm text-gray-500">
            Showing {filteredSuppliers.length} of {suppliers.length} supplier(s)
          </div>
            </>
          )}

          {activeSubsection === 'products' && (
            <SupplierProducts />
          )}

          {activeSubsection === 'cost-history' && (
            <SupplierCostHistory />
          )}
        </div>
      );
    }

    function SupplierProducts() {
      const [supplierProducts, setSupplierProducts] = useState([]);
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState(null);
      const [selectedSupplier, setSelectedSupplier] = useState('');
      const [suppliers, setSuppliers] = useState([]);

      useEffect(() => {
        fetchSuppliers();
      }, []);

      const fetchSuppliers = async () => {
        try {
          const response = await fetch('/admin/inventory/cutover/suppliers');
          const data = await response.json();
          if (data.success) {
            setSuppliers(data.suppliers || []);
          }
        } catch (err) {
          console.error('Failed to fetch suppliers:', err);
        }
      };

      const fetchSupplierProducts = async (supplierId) => {
        if (!supplierId) {
          setSupplierProducts([]);
          return;
        }
        setLoading(true);
        setError(null);
        try {
          // TODO: Replace with actual API endpoint
          const response = await fetch(`/admin/inventory/cutover/suppliers/${supplierId}/products`);
          const data = await response.json();
          if (data.success) {
            setSupplierProducts(data.products || []);
          } else {
            setError(data.message || 'Failed to fetch supplier products');
          }
        } catch (err) {
          setError(err.message || 'Failed to fetch supplier products');
        } finally {
          setLoading(false);
        }
      };

      useEffect(() => {
        if (selectedSupplier) {
          fetchSupplierProducts(selectedSupplier);
        }
      }, [selectedSupplier]);

      return (
        <div className="space-y-6">
          <div className="flex justify-between items-center">
            <h3 className="text-xl font-semibold text-gray-900">Supplier Products</h3>
          </div>

          {error && (
            <div className="p-3 bg-red-50 border border-red-200 rounded-md text-red-700 text-sm">
              {error}
            </div>
          )}

          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Select Supplier
              </label>
              <select
                value={selectedSupplier}
                onChange={(e) => setSelectedSupplier(e.target.value)}
                className="w-full md:w-64 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
              >
                <option value="">-- Select a supplier --</option>
                {suppliers.filter(s => s.isActive).map(supplier => (
                  <option key={supplier.id} value={supplier.id}>
                    {supplier.name}
                  </option>
                ))}
              </select>
            </div>

            {loading && (
              <div className="text-center py-8 text-gray-500">
                Loading supplier products...
              </div>
            )}

            {!loading && selectedSupplier && supplierProducts.length === 0 && (
              <div className="text-center py-8 text-gray-500">
                No products found for this supplier.
              </div>
            )}

            {!loading && selectedSupplier && supplierProducts.length > 0 && (
              <div className="bg-white border border-gray-200 rounded-lg overflow-hidden">
                <table className="min-w-full divide-y divide-gray-200">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Product Name
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        SKU
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Cost
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Last Updated
                      </th>
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {supplierProducts.map((product) => (
                      <tr key={product.id}>
                        <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                          {product.productName || product.name || 'N/A'}
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-600">
                          {product.sku || '‚Äî'}
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-600">
                          ${product.cost ? parseFloat(product.cost).toFixed(2) : '‚Äî'}
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-600">
                          {product.updatedAt ? new Date(product.updatedAt).toLocaleDateString() : '‚Äî'}
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </div>
        </div>
      );
    }

    function SupplierCostHistory() {
      const [costHistory, setCostHistory] = useState([]);
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState(null);
      const [selectedSupplier, setSelectedSupplier] = useState('');
      const [selectedProduct, setSelectedProduct] = useState('');
      const [suppliers, setSuppliers] = useState([]);
      const [products, setProducts] = useState([]);

      useEffect(() => {
        fetchSuppliers();
      }, []);

      const fetchSuppliers = async () => {
        try {
          const response = await fetch('/admin/inventory/cutover/suppliers');
          const data = await response.json();
          if (data.success) {
            setSuppliers(data.suppliers || []);
          }
        } catch (err) {
          console.error('Failed to fetch suppliers:', err);
        }
      };

      const fetchProducts = async (supplierId) => {
        if (!supplierId) {
          setProducts([]);
          return;
        }
        try {
          // TODO: Replace with actual API endpoint
          const response = await fetch(`/admin/inventory/cutover/suppliers/${supplierId}/products`);
          const data = await response.json();
          if (data.success) {
            setProducts(data.products || []);
          }
        } catch (err) {
          console.error('Failed to fetch products:', err);
        }
      };

      const fetchCostHistory = async (supplierId, productId) => {
        if (!supplierId || !productId) {
          setCostHistory([]);
          return;
        }
        setLoading(true);
        setError(null);
        try {
          // TODO: Replace with actual API endpoint
          const response = await fetch(`/admin/inventory/cutover/suppliers/${supplierId}/products/${productId}/cost-history`);
          const data = await response.json();
          if (data.success) {
            setCostHistory(data.costHistory || []);
          } else {
            setError(data.message || 'Failed to fetch cost history');
          }
        } catch (err) {
          setError(err.message || 'Failed to fetch cost history');
        } finally {
          setLoading(false);
        }
      };

      useEffect(() => {
        if (selectedSupplier) {
          fetchProducts(selectedSupplier);
          setSelectedProduct('');
          setCostHistory([]);
        }
      }, [selectedSupplier]);

      useEffect(() => {
        if (selectedSupplier && selectedProduct) {
          fetchCostHistory(selectedSupplier, selectedProduct);
        }
      }, [selectedSupplier, selectedProduct]);

      return (
        <div className="space-y-6">
          <div className="flex justify-between items-center">
            <h3 className="text-xl font-semibold text-gray-900">Supplier Cost History</h3>
          </div>

          {error && (
            <div className="p-3 bg-red-50 border border-red-200 rounded-md text-red-700 text-sm">
              {error}
            </div>
          )}

          <div className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Select Supplier
                </label>
                <select
                  value={selectedSupplier}
                  onChange={(e) => setSelectedSupplier(e.target.value)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                >
                  <option value="">-- Select a supplier --</option>
                  {suppliers.filter(s => s.isActive).map(supplier => (
                    <option key={supplier.id} value={supplier.id}>
                      {supplier.name}
                    </option>
                  ))}
                </select>
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Select Product
                </label>
                <select
                  value={selectedProduct}
                  onChange={(e) => setSelectedProduct(e.target.value)}
                  disabled={!selectedSupplier}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent disabled:bg-gray-100 disabled:cursor-not-allowed"
                >
                  <option value="">-- Select a product --</option>
                  {products.map(product => (
                    <option key={product.id} value={product.id}>
                      {product.productName || product.name || 'N/A'}
                    </option>
                  ))}
                </select>
              </div>
            </div>

            {loading && (
              <div className="text-center py-8 text-gray-500">
                Loading cost history...
              </div>
            )}

            {!loading && selectedSupplier && selectedProduct && costHistory.length === 0 && (
              <div className="text-center py-8 text-gray-500">
                No cost history found for this product.
              </div>
            )}

            {!loading && selectedSupplier && selectedProduct && costHistory.length > 0 && (
              <div className="bg-white border border-gray-200 rounded-lg overflow-hidden">
                <table className="min-w-full divide-y divide-gray-200">
                  <thead className="bg-gray-50">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Effective Date
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Cost
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Created At
                      </th>
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {costHistory.map((history, idx) => (
                      <tr key={idx}>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                          {history.effectiveAt ? new Date(history.effectiveAt).toLocaleDateString() : '‚Äî'}
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                          ${history.cost ? parseFloat(history.cost).toFixed(2) : '‚Äî'}
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-600">
                          {history.createdAt ? new Date(history.createdAt).toLocaleDateString() : '‚Äî'}
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </div>
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>

